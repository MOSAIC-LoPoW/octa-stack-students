ARM GAS  /tmp/ccpCMSI5.s 			page 1


   1              		.cpu cortex-m4
   2              		.eabi_attribute 27, 1
   3              		.eabi_attribute 28, 1
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 1
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.file	"modem_interface.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.text.verify_payload,"ax",%progbits
  18              		.align	1
  19              		.syntax unified
  20              		.thumb
  21              		.thumb_func
  22              		.fpu fpv4-sp-d16
  24              	verify_payload:
  25              	.LFB129:
  26              		.file 1 "../../shields/Murata/src/modem_interface.c"
   1:../../shields/Murata/src/modem_interface.c **** #include <string.h>
   2:../../shields/Murata/src/modem_interface.c **** 
   3:../../shields/Murata/src/modem_interface.c **** //#include "hwuart.h"
   4:../../shields/Murata/src/modem_interface.c **** 
   5:../../shields/Murata/src/modem_interface.c **** //#include "framework_defs.h"
   6:../../shields/Murata/src/modem_interface.c **** //#include "platform_defs.h"
   7:../../shields/Murata/src/modem_interface.c **** #include "fifo.h"
   8:../../shields/Murata/src/modem_interface.c **** //#include "scheduler.h"
   9:../../shields/Murata/src/modem_interface.c **** #include "modem_interface.h"
  10:../../shields/Murata/src/modem_interface.c **** //#include "hal_defs.h"
  11:../../shields/Murata/src/modem_interface.c **** //#include "debug.h"
  12:../../shields/Murata/src/modem_interface.c **** #include "errors.h"
  13:../../shields/Murata/src/modem_interface.c **** //#include "platform_defs.h"
  14:../../shields/Murata/src/modem_interface.c **** 
  15:../../shields/Murata/src/modem_interface.c **** //#include "hwsystem.h"
  16:../../shields/Murata/src/modem_interface.c **** //#include "hwatomic.h"
  17:../../shields/Murata/src/modem_interface.c **** #include "crc.h"
  18:../../shields/Murata/src/modem_interface.c **** 
  19:../../shields/Murata/src/modem_interface.c **** //#include "ng.h"
  20:../../shields/Murata/src/modem_interface.c **** #include "crc.h"
  21:../../shields/Murata/src/modem_interface.c **** 
  22:../../shields/Murata/src/modem_interface.c **** //#include "log.h"
  23:../../shields/Murata/src/modem_interface.c **** #include "stm32l4xx_hal.h"
  24:../../shields/Murata/src/modem_interface.c **** 
  25:../../shields/Murata/src/modem_interface.c **** 
  26:../../shields/Murata/src/modem_interface.c **** #define RX_BUFFER_SIZE 256
  27:../../shields/Murata/src/modem_interface.c **** 
  28:../../shields/Murata/src/modem_interface.c **** #define TX_FIFO_FLUSH_CHUNK_SIZE 10 // at a baudrate of 115200 this ensures completion within 1 ms
  29:../../shields/Murata/src/modem_interface.c ****                                     // TODO baudrate dependent
  30:../../shields/Murata/src/modem_interface.c **** #define PLATFORM_USE_MODEM_INTERRUPT_LINES 0
  31:../../shields/Murata/src/modem_interface.c **** #define HAL_UART_USE_DMA_TX 1
  32:../../shields/Murata/src/modem_interface.c **** //static uart_handle_t* uart;
ARM GAS  /tmp/ccpCMSI5.s 			page 2


  33:../../shields/Murata/src/modem_interface.c **** UART_HandleTypeDef* uart_handle;
  34:../../shields/Murata/src/modem_interface.c **** 
  35:../../shields/Murata/src/modem_interface.c **** static uint8_t rx_buffer[RX_BUFFER_SIZE];
  36:../../shields/Murata/src/modem_interface.c **** uint8_t rxData[1];
  37:../../shields/Murata/src/modem_interface.c **** fifo_t rx_fifo;
  38:../../shields/Murata/src/modem_interface.c **** 
  39:../../shields/Murata/src/modem_interface.c **** #if defined(FRAMEWORK_LOG_ENABLED) && defined(FRAMEWORK_MODEM_INTERFACE_LOG_ENABLED)
  40:../../shields/Murata/src/modem_interface.c ****   #define DPRINT(...) log_print_string(__VA_ARGS__)
  41:../../shields/Murata/src/modem_interface.c ****   #define DPRINT_DATA(...) log_print_data(__VA_ARGS__)
  42:../../shields/Murata/src/modem_interface.c **** #else
  43:../../shields/Murata/src/modem_interface.c ****   #define DPRINT(...)
  44:../../shields/Murata/src/modem_interface.c ****   #define DPRINT_DATA(...)
  45:../../shields/Murata/src/modem_interface.c **** #endif
  46:../../shields/Murata/src/modem_interface.c **** 
  47:../../shields/Murata/src/modem_interface.c **** 
  48:../../shields/Murata/src/modem_interface.c **** #define SERIAL_FRAME_SYNC_BYTE 0xC0
  49:../../shields/Murata/src/modem_interface.c **** #define SERIAL_FRAME_VERSION   0x00
  50:../../shields/Murata/src/modem_interface.c **** #define SERIAL_FRAME_HEADER_SIZE 7
  51:../../shields/Murata/src/modem_interface.c **** #define SERIAL_FRAME_SIZE 4
  52:../../shields/Murata/src/modem_interface.c **** #define SERIAL_FRAME_COUNTER 2
  53:../../shields/Murata/src/modem_interface.c **** #define SERIAL_FRAME_TYPE 3
  54:../../shields/Murata/src/modem_interface.c **** #define SERIAL_FRAME_CRC1   5
  55:../../shields/Murata/src/modem_interface.c **** #define SERIAL_FRAME_CRC2   6
  56:../../shields/Murata/src/modem_interface.c **** 
  57:../../shields/Murata/src/modem_interface.c **** #define MODEM_INTERFACE_TX_FIFO_SIZE 255
  58:../../shields/Murata/src/modem_interface.c **** static uint8_t modem_interface_tx_buffer[MODEM_INTERFACE_TX_FIFO_SIZE];
  59:../../shields/Murata/src/modem_interface.c **** static fifo_t modem_interface_tx_fifo;
  60:../../shields/Murata/src/modem_interface.c **** static bool request_pending = false;
  61:../../shields/Murata/src/modem_interface.c **** 
  62:../../shields/Murata/src/modem_interface.c **** uint8_t header[SERIAL_FRAME_HEADER_SIZE];
  63:../../shields/Murata/src/modem_interface.c **** static uint8_t payload_len = 0;
  64:../../shields/Murata/src/modem_interface.c **** static uint8_t packet_up_counter = 0;
  65:../../shields/Murata/src/modem_interface.c **** static uint8_t packet_down_counter = 0;
  66:../../shields/Murata/src/modem_interface.c **** //static pin_id_t uart_state_pin;
  67:../../shields/Murata/src/modem_interface.c **** //static pin_id_t target_uart_state_pin;
  68:../../shields/Murata/src/modem_interface.c **** 
  69:../../shields/Murata/src/modem_interface.c **** static bool modem_listen_uart_inited = false;
  70:../../shields/Murata/src/modem_interface.c **** static bool parsed_header = false;
  71:../../shields/Murata/src/modem_interface.c **** 
  72:../../shields/Murata/src/modem_interface.c **** static cmd_handler_t alp_handler;
  73:../../shields/Murata/src/modem_interface.c **** static cmd_handler_t ping_response_handler;
  74:../../shields/Murata/src/modem_interface.c **** static cmd_handler_t logging_handler;
  75:../../shields/Murata/src/modem_interface.c **** static target_rebooted_callback_t target_rebooted_cb;
  76:../../shields/Murata/src/modem_interface.c **** 
  77:../../shields/Murata/src/modem_interface.c **** typedef enum {
  78:../../shields/Murata/src/modem_interface.c ****   STATE_IDLE,
  79:../../shields/Murata/src/modem_interface.c ****   STATE_REQ_START,
  80:../../shields/Murata/src/modem_interface.c ****   STATE_REQ_WAIT,
  81:../../shields/Murata/src/modem_interface.c ****   STATE_REQ_BUSY,
  82:../../shields/Murata/src/modem_interface.c ****   STATE_RESP,
  83:../../shields/Murata/src/modem_interface.c ****   STATE_RESP_PENDING_REQ
  84:../../shields/Murata/src/modem_interface.c **** } state_t;
  85:../../shields/Murata/src/modem_interface.c **** 
  86:../../shields/Murata/src/modem_interface.c **** static state_t state = STATE_IDLE;
  87:../../shields/Murata/src/modem_interface.c **** 
  88:../../shields/Murata/src/modem_interface.c **** #define SWITCH_STATE(s) do { \
  89:../../shields/Murata/src/modem_interface.c ****   state = s; \
ARM GAS  /tmp/ccpCMSI5.s 			page 3


  90:../../shields/Murata/src/modem_interface.c ****   DPRINT("switch to %s\n", #s); \
  91:../../shields/Murata/src/modem_interface.c **** } while(0)
  92:../../shields/Murata/src/modem_interface.c **** 
  93:../../shields/Murata/src/modem_interface.c **** bool process_rx_fifo(void);
  94:../../shields/Murata/src/modem_interface.c **** void execute_state_machine(void);
  95:../../shields/Murata/src/modem_interface.c **** 
  96:../../shields/Murata/src/modem_interface.c **** 
  97:../../shields/Murata/src/modem_interface.c **** /** @Brief Enable UART interface and UART interrupt
  98:../../shields/Murata/src/modem_interface.c ****  *  @return void
  99:../../shields/Murata/src/modem_interface.c ****  */
 100:../../shields/Murata/src/modem_interface.c **** static void modem_interface_enable(void) 
 101:../../shields/Murata/src/modem_interface.c **** {
 102:../../shields/Murata/src/modem_interface.c ****   DPRINT("uart enabled @ %i",timer_get_counter_value());
 103:../../shields/Murata/src/modem_interface.c ****   //assert(uart_enable(uart));
 104:../../shields/Murata/src/modem_interface.c ****   //uart_rx_interrupt_enable(uart);
 105:../../shields/Murata/src/modem_interface.c ****   modem_listen_uart_inited = true;
 106:../../shields/Murata/src/modem_interface.c **** }
 107:../../shields/Murata/src/modem_interface.c **** 
 108:../../shields/Murata/src/modem_interface.c **** /** @Brief disables UART interface
 109:../../shields/Murata/src/modem_interface.c ****  *  @return void
 110:../../shields/Murata/src/modem_interface.c ****  */
 111:../../shields/Murata/src/modem_interface.c **** static void modem_interface_disable(void) 
 112:../../shields/Murata/src/modem_interface.c **** {
 113:../../shields/Murata/src/modem_interface.c ****   modem_listen_uart_inited = false;
 114:../../shields/Murata/src/modem_interface.c ****   //assert(uart_disable(uart));
 115:../../shields/Murata/src/modem_interface.c ****   DPRINT("uart disabled @ %i",timer_get_counter_value());
 116:../../shields/Murata/src/modem_interface.c **** }
 117:../../shields/Murata/src/modem_interface.c **** 
 118:../../shields/Murata/src/modem_interface.c **** /** @brief Lets receiver know that 
 119:../../shields/Murata/src/modem_interface.c ****  *  all the data has been transfered
 120:../../shields/Murata/src/modem_interface.c ****  *  @return void
 121:../../shields/Murata/src/modem_interface.c ****  */
 122:../../shields/Murata/src/modem_interface.c **** static void release_receiver()
 123:../../shields/Murata/src/modem_interface.c **** {
 124:../../shields/Murata/src/modem_interface.c **** #if PLATFORM_USE_MODEM_INTERRUPT_LINES
 125:../../shields/Murata/src/modem_interface.c ****   DPRINT("release receiver\n");
 126:../../shields/Murata/src/modem_interface.c ****   modem_interface_disable();
 127:../../shields/Murata/src/modem_interface.c ****   //hw_gpio_clr(uart_state_pin);
 128:../../shields/Murata/src/modem_interface.c ****   modem_release();
 129:../../shields/Murata/src/modem_interface.c **** #endif
 130:../../shields/Murata/src/modem_interface.c **** }
 131:../../shields/Murata/src/modem_interface.c **** 
 132:../../shields/Murata/src/modem_interface.c **** /** @brief transmit data in fifo to UART
 133:../../shields/Murata/src/modem_interface.c ****  *  @return void
 134:../../shields/Murata/src/modem_interface.c ****  */
 135:../../shields/Murata/src/modem_interface.c **** static void flush_modem_interface_tx_fifo(void *arg) 
 136:../../shields/Murata/src/modem_interface.c **** {
 137:../../shields/Murata/src/modem_interface.c ****   uint8_t len = fifo_get_size(&modem_interface_tx_fifo);
 138:../../shields/Murata/src/modem_interface.c **** 
 139:../../shields/Murata/src/modem_interface.c **** #ifdef HAL_UART_USE_DMA_TX
 140:../../shields/Murata/src/modem_interface.c ****   // when using DMA we transmit the whole FIFO at once
 141:../../shields/Murata/src/modem_interface.c ****   uint8_t buffer[MODEM_INTERFACE_TX_FIFO_SIZE];
 142:../../shields/Murata/src/modem_interface.c ****   fifo_pop(&modem_interface_tx_fifo, buffer, len);
 143:../../shields/Murata/src/modem_interface.c ****   //uart_send_bytes(uart, buffer, len);
 144:../../shields/Murata/src/modem_interface.c ****   HAL_UART_Transmit(uart_handle, buffer, len, 1000);
 145:../../shields/Murata/src/modem_interface.c **** #else
 146:../../shields/Murata/src/modem_interface.c ****   // only send small chunks over uart each invocation, to make sure
ARM GAS  /tmp/ccpCMSI5.s 			page 4


 147:../../shields/Murata/src/modem_interface.c ****   // we don't interfer with critical stack timings.
 148:../../shields/Murata/src/modem_interface.c ****   // When there is still data left in the fifo this will be rescheduled
 149:../../shields/Murata/src/modem_interface.c ****   // with lowest prio
 150:../../shields/Murata/src/modem_interface.c ****   uint8_t chunk[TX_FIFO_FLUSH_CHUNK_SIZE];
 151:../../shields/Murata/src/modem_interface.c ****   if(len <= TX_FIFO_FLUSH_CHUNK_SIZE)
 152:../../shields/Murata/src/modem_interface.c ****   {
 153:../../shields/Murata/src/modem_interface.c ****     fifo_pop(&modem_interface_tx_fifo, chunk, len);
 154:../../shields/Murata/src/modem_interface.c ****     //uart_send_bytes(uart, chunk, len);
 155:../../shields/Murata/src/modem_interface.c ****     HAL_UART_Transmit(uart_handle, chunk, len, 1000);
 156:../../shields/Murata/src/modem_interface.c ****     request_pending = false;
 157:../../shields/Murata/src/modem_interface.c ****     release_receiver();
 158:../../shields/Murata/src/modem_interface.c **** #if PLATFORM_USE_MODEM_INTERRUPT_LINES
 159:../../shields/Murata/src/modem_interface.c ****     //sched_post_task(&execute_state_machine);
 160:../../shields/Murata/src/modem_interface.c ****     execute_state_machine();
 161:../../shields/Murata/src/modem_interface.c **** #endif
 162:../../shields/Murata/src/modem_interface.c ****   } 
 163:../../shields/Murata/src/modem_interface.c ****   else 
 164:../../shields/Murata/src/modem_interface.c ****   {
 165:../../shields/Murata/src/modem_interface.c ****     fifo_pop(&modem_interface_tx_fifo, chunk, TX_FIFO_FLUSH_CHUNK_SIZE);
 166:../../shields/Murata/src/modem_interface.c ****     //uart_send_bytes(uart, chunk, TX_FIFO_FLUSH_CHUNK_SIZE);
 167:../../shields/Murata/src/modem_interface.c ****       HAL_UART_Transmit(uart_handle, chunk, TX_FIFO_FLUSH_CHUNK_SIZE, 1000);
 168:../../shields/Murata/src/modem_interface.c ****     //sched_post_task_prio(&flush_modem_interface_tx_fifo, MIN_PRIORITY, NULL);
 169:../../shields/Murata/src/modem_interface.c ****     flush_modem_interface_tx_fifo(NULL);
 170:../../shields/Murata/src/modem_interface.c ****   }
 171:../../shields/Murata/src/modem_interface.c **** #endif
 172:../../shields/Murata/src/modem_interface.c **** }
 173:../../shields/Murata/src/modem_interface.c **** 
 174:../../shields/Murata/src/modem_interface.c **** /** @Brief Keeps ÂµC awake while receiving UART data
 175:../../shields/Murata/src/modem_interface.c ****  *  @return void
 176:../../shields/Murata/src/modem_interface.c ****  */
 177:../../shields/Murata/src/modem_interface.c **** static void modem_listen(void* arg)
 178:../../shields/Murata/src/modem_interface.c **** {
 179:../../shields/Murata/src/modem_interface.c ****   if(!modem_listen_uart_inited)
 180:../../shields/Murata/src/modem_interface.c ****   {
 181:../../shields/Murata/src/modem_interface.c ****     modem_interface_enable();
 182:../../shields/Murata/src/modem_interface.c ****     //hw_gpio_set(uart_state_pin); //set interrupt gpio to indicate ready for data
 183:../../shields/Murata/src/modem_interface.c ****     modem_wakeup();
 184:../../shields/Murata/src/modem_interface.c ****     DPRINT("MODEM_ENABLE")
 185:../../shields/Murata/src/modem_interface.c ****   }
 186:../../shields/Murata/src/modem_interface.c ****   // prevent the MCU to go back to stop mode by scheduling ourself again until pin goes low,
 187:../../shields/Murata/src/modem_interface.c ****   // to keep UART RX enabled
 188:../../shields/Murata/src/modem_interface.c ****   //sched_post_task_prio(&modem_listen, MIN_PRIORITY, NULL);
 189:../../shields/Murata/src/modem_interface.c ****   while(HAL_GPIO_ReadPin(GPIOF, GPIO_PIN_5));
 190:../../shields/Murata/src/modem_interface.c **** }
 191:../../shields/Murata/src/modem_interface.c **** 
 192:../../shields/Murata/src/modem_interface.c **** 
 193:../../shields/Murata/src/modem_interface.c **** /** @Brief Schedules flush tx fifo when receiver is ready
 194:../../shields/Murata/src/modem_interface.c ****  *  @return void
 195:../../shields/Murata/src/modem_interface.c ****  */
 196:../../shields/Murata/src/modem_interface.c **** void execute_state_machine(void)
 197:../../shields/Murata/src/modem_interface.c **** {
 198:../../shields/Murata/src/modem_interface.c **** #if PLATFORM_USE_MODEM_INTERRUPT_LINES
 199:../../shields/Murata/src/modem_interface.c ****   switch(state) {
 200:../../shields/Murata/src/modem_interface.c ****     case STATE_RESP:
 201:../../shields/Murata/src/modem_interface.c ****       // response period completed, process the request
 202:../../shields/Murata/src/modem_interface.c ****       //assert(!hw_gpio_get_in(target_uart_state_pin));
 203:../../shields/Murata/src/modem_interface.c ****       //sched_post_task(&process_rx_fifo);
ARM GAS  /tmp/ccpCMSI5.s 			page 5


 204:../../shields/Murata/src/modem_interface.c ****       process_rx_fifo();
 205:../../shields/Murata/src/modem_interface.c ****       if(request_pending) {
 206:../../shields/Murata/src/modem_interface.c ****         SWITCH_STATE(STATE_RESP_PENDING_REQ);
 207:../../shields/Murata/src/modem_interface.c ****         //sched_post_task(&execute_state_machine);
 208:../../shields/Murata/src/modem_interface.c ****         execute_state_machine();
 209:../../shields/Murata/src/modem_interface.c ****       } else {
 210:../../shields/Murata/src/modem_interface.c ****         SWITCH_STATE(STATE_IDLE);
 211:../../shields/Murata/src/modem_interface.c ****         //hw_gpio_clr(uart_state_pin);
 212:../../shields/Murata/src/modem_interface.c ****         modem_release();
 213:../../shields/Murata/src/modem_interface.c ****         //sched_cancel_task(&modem_listen);??
 214:../../shields/Murata/src/modem_interface.c ****         modem_interface_disable();
 215:../../shields/Murata/src/modem_interface.c ****       }
 216:../../shields/Murata/src/modem_interface.c ****       break;
 217:../../shields/Murata/src/modem_interface.c ****     case STATE_IDLE:
 218:../../shields/Murata/src/modem_interface.c ****       //if(hw_gpio_get_in(target_uart_state_pin)) {
 219:../../shields/Murata/src/modem_interface.c ****       if(HAL_GPIO_ReadPin(GPIOF, GPIO_PIN_5)){
 220:../../shields/Murata/src/modem_interface.c ****         // wake-up requested
 221:../../shields/Murata/src/modem_interface.c ****         SWITCH_STATE(STATE_RESP);
 222:../../shields/Murata/src/modem_interface.c ****         modem_listen(NULL);
 223:../../shields/Murata/src/modem_interface.c **** 
 224:../../shields/Murata/src/modem_interface.c ****         execute_state_machine();
 225:../../shields/Murata/src/modem_interface.c **** 
 226:../../shields/Murata/src/modem_interface.c ****         break;
 227:../../shields/Murata/src/modem_interface.c ****       } else if(request_pending) { //check if we are really requesting a start
 228:../../shields/Murata/src/modem_interface.c ****         SWITCH_STATE(STATE_REQ_START);
 229:../../shields/Murata/src/modem_interface.c ****         // fall-through to STATE_REQ_START!
 230:../../shields/Murata/src/modem_interface.c ****       } else
 231:../../shields/Murata/src/modem_interface.c ****       {
 232:../../shields/Murata/src/modem_interface.c ****         break;
 233:../../shields/Murata/src/modem_interface.c ****       }
 234:../../shields/Murata/src/modem_interface.c ****     case STATE_REQ_START:
 235:../../shields/Murata/src/modem_interface.c ****       // TODO timeout
 236:../../shields/Murata/src/modem_interface.c ****       //sched_cancel_task(&modem_listen);
 237:../../shields/Murata/src/modem_interface.c ****       SWITCH_STATE(STATE_REQ_WAIT);
 238:../../shields/Murata/src/modem_interface.c ****       //hw_gpio_set(uart_state_pin); // wake-up receiver
 239:../../shields/Murata/src/modem_interface.c ****       modem_wakeup();
 240:../../shields/Murata/src/modem_interface.c ****       DPRINT("wake-up receiver\n");
 241:../../shields/Murata/src/modem_interface.c ****       //sched_post_task(&execute_state_machine); // reschedule again to prevent sleeoping
 242:../../shields/Murata/src/modem_interface.c ****       execute_state_machine();
 243:../../shields/Murata/src/modem_interface.c ****       // in principle we could go to sleep but this will cause pin to float, this can be improved l
 244:../../shields/Murata/src/modem_interface.c ****       break;
 245:../../shields/Murata/src/modem_interface.c ****     case STATE_REQ_WAIT:
 246:../../shields/Murata/src/modem_interface.c ****       //if(hw_gpio_get_in(target_uart_state_pin)) {
 247:../../shields/Murata/src/modem_interface.c ****       if(HAL_GPIO_ReadPin(GPIOF, GPIO_PIN_5)){
 248:../../shields/Murata/src/modem_interface.c ****         // receiver active
 249:../../shields/Murata/src/modem_interface.c ****         SWITCH_STATE(STATE_REQ_BUSY);
 250:../../shields/Murata/src/modem_interface.c ****         //execute_state_machine();
 251:../../shields/Murata/src/modem_interface.c ****         // fall-through to STATE_REQ_BUSY!
 252:../../shields/Murata/src/modem_interface.c ****       } else {
 253:../../shields/Murata/src/modem_interface.c ****         // TODO timeout
 254:../../shields/Murata/src/modem_interface.c ****         //sched_post_task(&execute_state_machine); // reschedule again to prevent sleeoping
 255:../../shields/Murata/src/modem_interface.c ****         execute_state_machine();
 256:../../shields/Murata/src/modem_interface.c ****         // in principle we could go to sleep but this will cause pin to float, this can be improved
 257:../../shields/Murata/src/modem_interface.c ****         //SWITCH_STATE(STATE_REQ_BUSY);
 258:../../shields/Murata/src/modem_interface.c ****         break;
 259:../../shields/Murata/src/modem_interface.c ****       }
 260:../../shields/Murata/src/modem_interface.c ****     case STATE_REQ_BUSY:
ARM GAS  /tmp/ccpCMSI5.s 			page 6


 261:../../shields/Murata/src/modem_interface.c ****       if(request_pending) {
 262:../../shields/Murata/src/modem_interface.c ****         modem_interface_enable();
 263:../../shields/Murata/src/modem_interface.c ****         //sched_post_task_prio(&flush_modem_interface_tx_fifo, MIN_PRIORITY, NULL);
 264:../../shields/Murata/src/modem_interface.c ****         flush_modem_interface_tx_fifo(NULL);
 265:../../shields/Murata/src/modem_interface.c ****       //} else if (!hw_gpio_get_in(target_uart_state_pin)){
 266:../../shields/Murata/src/modem_interface.c ****       }else if (!HAL_GPIO_ReadPin(GPIOF, GPIO_PIN_5)){
 267:../../shields/Murata/src/modem_interface.c ****         SWITCH_STATE(STATE_IDLE);
 268:../../shields/Murata/src/modem_interface.c ****       } else{
 269:../../shields/Murata/src/modem_interface.c ****         //sched_post_task(&execute_state_machine); 
 270:../../shields/Murata/src/modem_interface.c ****         execute_state_machine();
 271:../../shields/Murata/src/modem_interface.c ****         //keep active until target reacts
 272:../../shields/Murata/src/modem_interface.c ****       }
 273:../../shields/Murata/src/modem_interface.c ****       break;
 274:../../shields/Murata/src/modem_interface.c ****     case STATE_RESP_PENDING_REQ:
 275:../../shields/Murata/src/modem_interface.c ****       //assert(request_pending);
 276:../../shields/Murata/src/modem_interface.c ****       // response period completed, initiate pending request by switching to REQ_START
 277:../../shields/Murata/src/modem_interface.c ****       //assert(!hw_gpio_get_in(target_uart_state_pin));
 278:../../shields/Murata/src/modem_interface.c ****       //hw_gpio_clr(uart_state_pin);
 279:../../shields/Murata/src/modem_interface.c ****       modem_release();
 280:../../shields/Murata/src/modem_interface.c ****       SWITCH_STATE(STATE_REQ_START);
 281:../../shields/Murata/src/modem_interface.c ****       //sched_post_task(&execute_state_machine);
 282:../../shields/Murata/src/modem_interface.c ****       execute_state_machine();
 283:../../shields/Murata/src/modem_interface.c ****       break;
 284:../../shields/Murata/src/modem_interface.c ****     default:
 285:../../shields/Murata/src/modem_interface.c ****       DPRINT("unexpected state %i\n", state);
 286:../../shields/Murata/src/modem_interface.c ****       //assert(false);
 287:../../shields/Murata/src/modem_interface.c ****   }
 288:../../shields/Murata/src/modem_interface.c **** #endif
 289:../../shields/Murata/src/modem_interface.c **** }
 290:../../shields/Murata/src/modem_interface.c **** 
 291:../../shields/Murata/src/modem_interface.c **** /** @Brief Check package counter and crc
 292:../../shields/Murata/src/modem_interface.c ****  *  @return void
 293:../../shields/Murata/src/modem_interface.c ****  */
 294:../../shields/Murata/src/modem_interface.c **** static bool verify_payload(fifo_t* bytes, uint8_t* header)
 295:../../shields/Murata/src/modem_interface.c **** {
  27              		.loc 1 295 0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 0
  30              		@ frame_needed = 1, uses_anonymous_args = 0
  31              	.LVL0:
  32 0000 B0B5     		push	{r4, r5, r7, lr}
  33              	.LCFI0:
  34              		.cfi_def_cfa_offset 16
  35              		.cfi_offset 4, -16
  36              		.cfi_offset 5, -12
  37              		.cfi_offset 7, -8
  38              		.cfi_offset 14, -4
  39 0002 00AF     		add	r7, sp, #0
  40              	.LCFI1:
  41              		.cfi_def_cfa_register 7
  42 0004 0C46     		mov	r4, r1
 296:../../shields/Murata/src/modem_interface.c ****   uint8_t payload[header[SERIAL_FRAME_SIZE]];
  43              		.loc 1 296 0
  44 0006 0B79     		ldrb	r3, [r1, #4]	@ zero_extendqisi2
  45              	.LVL1:
  46 0008 DA1D     		adds	r2, r3, #7
  47 000a 02F4FC72 		and	r2, r2, #504
ARM GAS  /tmp/ccpCMSI5.s 			page 7


  48 000e ADEB020D 		sub	sp, sp, r2
  49 0012 6D46     		mov	r5, sp
  50              	.LVL2:
 297:../../shields/Murata/src/modem_interface.c ****   fifo_peek(bytes, (uint8_t*) &payload, 0, header[SERIAL_FRAME_SIZE]);
  51              		.loc 1 297 0
  52 0014 0022     		movs	r2, #0
  53 0016 6946     		mov	r1, sp
  54              	.LVL3:
  55 0018 FFF7FEFF 		bl	fifo_peek
  56              	.LVL4:
 298:../../shields/Murata/src/modem_interface.c **** 
 299:../../shields/Murata/src/modem_interface.c ****   //check for missing packages
 300:../../shields/Murata/src/modem_interface.c ****   packet_down_counter++;
  57              		.loc 1 300 0
  58 001c 0E4A     		ldr	r2, .L8
  59 001e 1378     		ldrb	r3, [r2]	@ zero_extendqisi2
  60 0020 0133     		adds	r3, r3, #1
  61 0022 DBB2     		uxtb	r3, r3
  62 0024 1370     		strb	r3, [r2]
 301:../../shields/Murata/src/modem_interface.c ****   if(header[SERIAL_FRAME_COUNTER]!=packet_down_counter)
  63              		.loc 1 301 0
  64 0026 A278     		ldrb	r2, [r4, #2]	@ zero_extendqisi2
  65 0028 9342     		cmp	r3, r2
  66 002a 01D0     		beq	.L2
 302:../../shields/Murata/src/modem_interface.c ****   {
 303:../../shields/Murata/src/modem_interface.c ****     //TODO consequence? (save total missing packages?)
 304:../../shields/Murata/src/modem_interface.c ****     //log_print_string("!!! missed packages: %i",(header[SERIAL_FRAME_COUNTER]-packet_down_counter)
 305:../../shields/Murata/src/modem_interface.c ****     packet_down_counter=header[SERIAL_FRAME_COUNTER]; //reset package counter
  67              		.loc 1 305 0
  68 002c 0A4B     		ldr	r3, .L8
  69 002e 1A70     		strb	r2, [r3]
  70              	.L2:
 306:../../shields/Murata/src/modem_interface.c ****   }
 307:../../shields/Murata/src/modem_interface.c **** 
 308:../../shields/Murata/src/modem_interface.c ****   DPRINT("RX HEADER: ");
 309:../../shields/Murata/src/modem_interface.c ****   DPRINT_DATA(header, SERIAL_FRAME_HEADER_SIZE);
 310:../../shields/Murata/src/modem_interface.c ****   DPRINT("RX PAYLOAD: ");
 311:../../shields/Murata/src/modem_interface.c ****   DPRINT_DATA(payload, header[SERIAL_FRAME_SIZE]);
 312:../../shields/Murata/src/modem_interface.c **** 
 313:../../shields/Murata/src/modem_interface.c ****   uint16_t calculated_crc = crc_calculate(payload, header[SERIAL_FRAME_SIZE]);
  71              		.loc 1 313 0
  72 0030 2179     		ldrb	r1, [r4, #4]	@ zero_extendqisi2
  73 0032 2846     		mov	r0, r5
  74 0034 FFF7FEFF 		bl	crc_calculate
  75              	.LVL5:
 314:../../shields/Murata/src/modem_interface.c ****  
 315:../../shields/Murata/src/modem_interface.c ****   if(header[SERIAL_FRAME_CRC1]!=((calculated_crc >> 8) & 0x00FF) || header[SERIAL_FRAME_CRC2]!=(cal
  76              		.loc 1 315 0
  77 0038 6279     		ldrb	r2, [r4, #5]	@ zero_extendqisi2
  78 003a C0F30F23 		ubfx	r3, r0, #8, #16
  79 003e 9A42     		cmp	r2, r3
  80 0040 02D0     		beq	.L7
 316:../../shields/Murata/src/modem_interface.c ****   {
 317:../../shields/Murata/src/modem_interface.c ****     //TODO consequence? (request repeat?)
 318:../../shields/Murata/src/modem_interface.c ****     //log_print_string("CRC incorrect!");
 319:../../shields/Murata/src/modem_interface.c ****     return false;
  81              		.loc 1 319 0
ARM GAS  /tmp/ccpCMSI5.s 			page 8


  82 0042 0020     		movs	r0, #0
  83              	.LVL6:
  84              	.L3:
 320:../../shields/Murata/src/modem_interface.c ****   }
 321:../../shields/Murata/src/modem_interface.c ****   else
 322:../../shields/Murata/src/modem_interface.c ****     return true;
 323:../../shields/Murata/src/modem_interface.c **** }
  85              		.loc 1 323 0
  86 0044 BD46     		mov	sp, r7
  87              	.LCFI2:
  88              		.cfi_remember_state
  89              		.cfi_def_cfa_register 13
  90              		@ sp needed
  91 0046 B0BD     		pop	{r4, r5, r7, pc}
  92              	.LVL7:
  93              	.L7:
  94              	.LCFI3:
  95              		.cfi_restore_state
 315:../../shields/Murata/src/modem_interface.c ****   {
  96              		.loc 1 315 0 discriminator 1
  97 0048 A379     		ldrb	r3, [r4, #6]	@ zero_extendqisi2
  98 004a C0B2     		uxtb	r0, r0
  99              	.LVL8:
 100 004c 8342     		cmp	r3, r0
 101 004e 01D0     		beq	.L5
 319:../../shields/Murata/src/modem_interface.c ****   }
 102              		.loc 1 319 0
 103 0050 0020     		movs	r0, #0
 104 0052 F7E7     		b	.L3
 105              	.L5:
 322:../../shields/Murata/src/modem_interface.c **** }
 106              		.loc 1 322 0
 107 0054 0120     		movs	r0, #1
 108 0056 F5E7     		b	.L3
 109              	.L9:
 110              		.align	2
 111              	.L8:
 112 0058 00000000 		.word	.LANCHOR0
 113              		.cfi_endproc
 114              	.LFE129:
 116              		.section	.text.flush_modem_interface_tx_fifo,"ax",%progbits
 117              		.align	1
 118              		.syntax unified
 119              		.thumb
 120              		.thumb_func
 121              		.fpu fpv4-sp-d16
 123              	flush_modem_interface_tx_fifo:
 124              	.LFB126:
 136:../../shields/Murata/src/modem_interface.c ****   uint8_t len = fifo_get_size(&modem_interface_tx_fifo);
 125              		.loc 1 136 0
 126              		.cfi_startproc
 127              		@ args = 0, pretend = 0, frame = 256
 128              		@ frame_needed = 0, uses_anonymous_args = 0
 129              	.LVL9:
 130 0000 30B5     		push	{r4, r5, lr}
 131              	.LCFI4:
 132              		.cfi_def_cfa_offset 12
ARM GAS  /tmp/ccpCMSI5.s 			page 9


 133              		.cfi_offset 4, -12
 134              		.cfi_offset 5, -8
 135              		.cfi_offset 14, -4
 136 0002 C1B0     		sub	sp, sp, #260
 137              	.LCFI5:
 138              		.cfi_def_cfa_offset 272
 137:../../shields/Murata/src/modem_interface.c **** 
 139              		.loc 1 137 0
 140 0004 094D     		ldr	r5, .L12
 141 0006 2846     		mov	r0, r5
 142              	.LVL10:
 143 0008 FFF7FEFF 		bl	fifo_get_size
 144              	.LVL11:
 145 000c C4B2     		uxtb	r4, r0
 142:../../shields/Murata/src/modem_interface.c ****   //uart_send_bytes(uart, buffer, len);
 146              		.loc 1 142 0
 147 000e 2246     		mov	r2, r4
 148 0010 6946     		mov	r1, sp
 149 0012 2846     		mov	r0, r5
 150              	.LVL12:
 151 0014 FFF7FEFF 		bl	fifo_pop
 152              	.LVL13:
 144:../../shields/Murata/src/modem_interface.c **** #else
 153              		.loc 1 144 0
 154 0018 4FF47A73 		mov	r3, #1000
 155 001c 2246     		mov	r2, r4
 156 001e 6946     		mov	r1, sp
 157 0020 0348     		ldr	r0, .L12+4
 158 0022 0068     		ldr	r0, [r0]
 159 0024 FFF7FEFF 		bl	HAL_UART_Transmit
 160              	.LVL14:
 172:../../shields/Murata/src/modem_interface.c **** 
 161              		.loc 1 172 0
 162 0028 41B0     		add	sp, sp, #260
 163              	.LCFI6:
 164              		.cfi_def_cfa_offset 12
 165              		@ sp needed
 166 002a 30BD     		pop	{r4, r5, pc}
 167              	.LVL15:
 168              	.L13:
 169              		.align	2
 170              	.L12:
 171 002c 00000000 		.word	.LANCHOR1
 172 0030 00000000 		.word	uart_handle
 173              		.cfi_endproc
 174              	.LFE126:
 176              		.section	.text.execute_state_machine,"ax",%progbits
 177              		.align	1
 178              		.global	execute_state_machine
 179              		.syntax unified
 180              		.thumb
 181              		.thumb_func
 182              		.fpu fpv4-sp-d16
 184              	execute_state_machine:
 185              	.LFB128:
 197:../../shields/Murata/src/modem_interface.c **** #if PLATFORM_USE_MODEM_INTERRUPT_LINES
 186              		.loc 1 197 0
ARM GAS  /tmp/ccpCMSI5.s 			page 10


 187              		.cfi_startproc
 188              		@ args = 0, pretend = 0, frame = 0
 189              		@ frame_needed = 0, uses_anonymous_args = 0
 190              		@ link register save eliminated.
 289:../../shields/Murata/src/modem_interface.c **** 
 191              		.loc 1 289 0
 192 0000 7047     		bx	lr
 193              		.cfi_endproc
 194              	.LFE128:
 196              		.section	.text.modem_interface_uart_rx_cb,"ax",%progbits
 197              		.align	1
 198              		.global	modem_interface_uart_rx_cb
 199              		.syntax unified
 200              		.thumb
 201              		.thumb_func
 202              		.fpu fpv4-sp-d16
 204              	modem_interface_uart_rx_cb:
 205              	.LFB132:
 324:../../shields/Murata/src/modem_interface.c **** 
 325:../../shields/Murata/src/modem_interface.c **** /** @Brief Processes received uart data
 326:../../shields/Murata/src/modem_interface.c ****  * 1) Search for sync bytes (always)
 327:../../shields/Murata/src/modem_interface.c ****  * 2) get header size and parse header
 328:../../shields/Murata/src/modem_interface.c ****  * 3) Wait for correct # of bytes (length present in header)
 329:../../shields/Murata/src/modem_interface.c ****  * 4) Execute crc check and check message counter
 330:../../shields/Murata/src/modem_interface.c ****  * 5) send to corresponding service (alp, ping service, log service)
 331:../../shields/Murata/src/modem_interface.c ****  *  @return void
 332:../../shields/Murata/src/modem_interface.c ****  */
 333:../../shields/Murata/src/modem_interface.c **** bool process_rx_fifo(void) 
 334:../../shields/Murata/src/modem_interface.c **** {
 335:../../shields/Murata/src/modem_interface.c ****   if(!parsed_header) 
 336:../../shields/Murata/src/modem_interface.c ****   {
 337:../../shields/Murata/src/modem_interface.c ****     if(fifo_get_size(&rx_fifo) > SERIAL_FRAME_HEADER_SIZE) 
 338:../../shields/Murata/src/modem_interface.c ****     {
 339:../../shields/Murata/src/modem_interface.c ****         fifo_peek(&rx_fifo, header, 0, SERIAL_FRAME_HEADER_SIZE);
 340:../../shields/Murata/src/modem_interface.c **** 
 341:../../shields/Murata/src/modem_interface.c ****         if(header[0] != SERIAL_FRAME_SYNC_BYTE || header[1] != SERIAL_FRAME_VERSION) 
 342:../../shields/Murata/src/modem_interface.c ****         {
 343:../../shields/Murata/src/modem_interface.c ****           fifo_skip(&rx_fifo, 1);
 344:../../shields/Murata/src/modem_interface.c ****           DPRINT("skip");
 345:../../shields/Murata/src/modem_interface.c ****           parsed_header = false;
 346:../../shields/Murata/src/modem_interface.c ****           payload_len = 0;
 347:../../shields/Murata/src/modem_interface.c ****           if(fifo_get_size(&rx_fifo) > SERIAL_FRAME_HEADER_SIZE)
 348:../../shields/Murata/src/modem_interface.c ****             //process_rx_fifo();
 349:../../shields/Murata/src/modem_interface.c ****             //sched_post_task(&process_rx_fifo);
 350:../../shields/Murata/src/modem_interface.c ****           return false;
 351:../../shields/Murata/src/modem_interface.c ****         }
 352:../../shields/Murata/src/modem_interface.c ****         parsed_header = true;
 353:../../shields/Murata/src/modem_interface.c ****         fifo_skip(&rx_fifo, SERIAL_FRAME_HEADER_SIZE);
 354:../../shields/Murata/src/modem_interface.c ****         payload_len = header[SERIAL_FRAME_SIZE];
 355:../../shields/Murata/src/modem_interface.c ****         DPRINT("UART RX, payload size = %i", payload_len);
 356:../../shields/Murata/src/modem_interface.c ****         //sched_post_task(&process_rx_fifo);
 357:../../shields/Murata/src/modem_interface.c ****         //process_rx_fifo();
 358:../../shields/Murata/src/modem_interface.c ****     }
 359:../../shields/Murata/src/modem_interface.c ****   }
 360:../../shields/Murata/src/modem_interface.c ****   else 
 361:../../shields/Murata/src/modem_interface.c ****   {
 362:../../shields/Murata/src/modem_interface.c ****     if(fifo_get_size(&rx_fifo) < payload_len) {
ARM GAS  /tmp/ccpCMSI5.s 			page 11


 363:../../shields/Murata/src/modem_interface.c ****       //process_rx_fifo();
 364:../../shields/Murata/src/modem_interface.c ****       return false;
 365:../../shields/Murata/src/modem_interface.c ****     }
 366:../../shields/Murata/src/modem_interface.c ****     // payload complete, start parsing
 367:../../shields/Murata/src/modem_interface.c ****     // rx_fifo can be bigger than the current serial packet, init a subview fifo
 368:../../shields/Murata/src/modem_interface.c ****     // which is restricted to payload_len so we can't parse past this packet.
 369:../../shields/Murata/src/modem_interface.c ****     fifo_t payload_fifo;
 370:../../shields/Murata/src/modem_interface.c ****     fifo_init_subview(&payload_fifo, &rx_fifo, 0, payload_len);
 371:../../shields/Murata/src/modem_interface.c ****   
 372:../../shields/Murata/src/modem_interface.c ****     if(verify_payload(&payload_fifo,(uint8_t *)&header))
 373:../../shields/Murata/src/modem_interface.c ****     {
 374:../../shields/Murata/src/modem_interface.c ****       if(header[SERIAL_FRAME_TYPE]==SERIAL_MESSAGE_TYPE_ALP_DATA && alp_handler != NULL)
 375:../../shields/Murata/src/modem_interface.c ****         alp_handler(&payload_fifo);
 376:../../shields/Murata/src/modem_interface.c ****       else if (header[SERIAL_FRAME_TYPE]==SERIAL_MESSAGE_TYPE_PING_RESPONSE  && ping_response_handl
 377:../../shields/Murata/src/modem_interface.c ****         ping_response_handler(&payload_fifo);
 378:../../shields/Murata/src/modem_interface.c ****       else if (header[SERIAL_FRAME_TYPE]==SERIAL_MESSAGE_TYPE_LOGGING && logging_handler != NULL)
 379:../../shields/Murata/src/modem_interface.c ****         logging_handler(&payload_fifo);
 380:../../shields/Murata/src/modem_interface.c ****       else if (header[SERIAL_FRAME_TYPE]==SERIAL_MESSAGE_TYPE_PING_REQUEST)
 381:../../shields/Murata/src/modem_interface.c ****       {
 382:../../shields/Murata/src/modem_interface.c ****         uint8_t ping_reply[1]={0x02};
 383:../../shields/Murata/src/modem_interface.c ****         fifo_skip(&payload_fifo,1);
 384:../../shields/Murata/src/modem_interface.c ****         modem_interface_transfer_bytes((uint8_t*) &ping_reply,1,SERIAL_MESSAGE_TYPE_PING_RESPONSE);
 385:../../shields/Murata/src/modem_interface.c ****       }
 386:../../shields/Murata/src/modem_interface.c ****       else if(header[SERIAL_FRAME_TYPE]==SERIAL_MESSAGE_TYPE_REBOOTED)
 387:../../shields/Murata/src/modem_interface.c ****       {
 388:../../shields/Murata/src/modem_interface.c ****         uint8_t reboot_reason;
 389:../../shields/Murata/src/modem_interface.c ****         fifo_pop(&payload_fifo, &reboot_reason, 1);
 390:../../shields/Murata/src/modem_interface.c ****         printf("target rebooted, reason=%i\n", reboot_reason);
 391:../../shields/Murata/src/modem_interface.c ****         if(target_rebooted_cb)
 392:../../shields/Murata/src/modem_interface.c ****           target_rebooted_cb(reboot_reason);
 393:../../shields/Murata/src/modem_interface.c ****       }
 394:../../shields/Murata/src/modem_interface.c ****       else
 395:../../shields/Murata/src/modem_interface.c ****       {
 396:../../shields/Murata/src/modem_interface.c ****         fifo_skip(&payload_fifo, payload_len);
 397:../../shields/Murata/src/modem_interface.c ****         DPRINT("!!!FRAME TYPE NOT IMPLEMENTED");
 398:../../shields/Murata/src/modem_interface.c ****       }
 399:../../shields/Murata/src/modem_interface.c ****       fifo_skip(&rx_fifo, payload_len - fifo_get_size(&payload_fifo)); // pop parsed bytes from ori
 400:../../shields/Murata/src/modem_interface.c ****     }
 401:../../shields/Murata/src/modem_interface.c ****     else
 402:../../shields/Murata/src/modem_interface.c ****       DPRINT("!!!PAYLOAD DATA INCORRECT");
 403:../../shields/Murata/src/modem_interface.c ****     payload_len = 0;
 404:../../shields/Murata/src/modem_interface.c ****     parsed_header = false;
 405:../../shields/Murata/src/modem_interface.c ****     if(fifo_get_size(&rx_fifo) > SERIAL_FRAME_HEADER_SIZE)
 406:../../shields/Murata/src/modem_interface.c ****         //process_rx_fifo();
 407:../../shields/Murata/src/modem_interface.c ****       //sched_post_task(&process_rx_fifo);
 408:../../shields/Murata/src/modem_interface.c ****     return true;
 409:../../shields/Murata/src/modem_interface.c ****   }
 410:../../shields/Murata/src/modem_interface.c ****   return false;
 411:../../shields/Murata/src/modem_interface.c **** }
 412:../../shields/Murata/src/modem_interface.c **** /** @Brief put received UART data in fifo
 413:../../shields/Murata/src/modem_interface.c ****  *  @return void
 414:../../shields/Murata/src/modem_interface.c ****  */
 415:../../shields/Murata/src/modem_interface.c **** static void uart_rx_cb(uint8_t data)
 416:../../shields/Murata/src/modem_interface.c **** {
 417:../../shields/Murata/src/modem_interface.c ****     error_t err;
 418:../../shields/Murata/src/modem_interface.c ****     //start_atomic();
 419:../../shields/Murata/src/modem_interface.c ****         err = fifo_put(&rx_fifo, &data, 1); assert(err == SUCCESS);
ARM GAS  /tmp/ccpCMSI5.s 			page 12


 420:../../shields/Murata/src/modem_interface.c ****     //end_atomic();
 421:../../shields/Murata/src/modem_interface.c **** 
 422:../../shields/Murata/src/modem_interface.c **** #ifndef PLATFORM_USE_MODEM_INTERRUPT_LINES
 423:../../shields/Murata/src/modem_interface.c ****     //sched_post_task(&process_rx_fifo);
 424:../../shields/Murata/src/modem_interface.c ****     process_rx_fifo();
 425:../../shields/Murata/src/modem_interface.c **** #endif
 426:../../shields/Murata/src/modem_interface.c **** }
 427:../../shields/Murata/src/modem_interface.c **** 
 428:../../shields/Murata/src/modem_interface.c **** void modem_interface_uart_rx_cb()
 429:../../shields/Murata/src/modem_interface.c **** {
 206              		.loc 1 429 0
 207              		.cfi_startproc
 208              		@ args = 0, pretend = 0, frame = 0
 209              		@ frame_needed = 0, uses_anonymous_args = 0
 210 0000 10B5     		push	{r4, lr}
 211              	.LCFI7:
 212              		.cfi_def_cfa_offset 8
 213              		.cfi_offset 4, -8
 214              		.cfi_offset 14, -4
 430:../../shields/Murata/src/modem_interface.c ****     HAL_UART_Receive_IT(uart_handle, rxData, 1);
 215              		.loc 1 430 0
 216 0002 064C     		ldr	r4, .L17
 217 0004 0122     		movs	r2, #1
 218 0006 2146     		mov	r1, r4
 219 0008 054B     		ldr	r3, .L17+4
 220 000a 1868     		ldr	r0, [r3]
 221 000c FFF7FEFF 		bl	HAL_UART_Receive_IT
 222              	.LVL16:
 431:../../shields/Murata/src/modem_interface.c ****     error_t err;
 432:../../shields/Murata/src/modem_interface.c ****     //start_atomic();
 433:../../shields/Murata/src/modem_interface.c ****         err = fifo_put(&rx_fifo, rxData, 1); //assert(err == SUCCESS);
 223              		.loc 1 433 0
 224 0010 0122     		movs	r2, #1
 225 0012 2146     		mov	r1, r4
 226 0014 0348     		ldr	r0, .L17+8
 227 0016 FFF7FEFF 		bl	fifo_put
 228              	.LVL17:
 434:../../shields/Murata/src/modem_interface.c ****     //end_atomic();
 435:../../shields/Murata/src/modem_interface.c ****     
 436:../../shields/Murata/src/modem_interface.c **** #ifndef PLATFORM_USE_MODEM_INTERRUPT_LINES
 437:../../shields/Murata/src/modem_interface.c ****     //sched_post_task(&process_rx_fifo);
 438:../../shields/Murata/src/modem_interface.c ****     process_rx_fifo();
 439:../../shields/Murata/src/modem_interface.c **** #endif
 440:../../shields/Murata/src/modem_interface.c **** }
 229              		.loc 1 440 0
 230 001a 10BD     		pop	{r4, pc}
 231              	.L18:
 232              		.align	2
 233              	.L17:
 234 001c 00000000 		.word	rxData
 235 0020 00000000 		.word	uart_handle
 236 0024 00000000 		.word	rx_fifo
 237              		.cfi_endproc
 238              	.LFE132:
 240              		.section	.text.modem_interface_transfer_bytes,"ax",%progbits
 241              		.align	1
 242              		.global	modem_interface_transfer_bytes
ARM GAS  /tmp/ccpCMSI5.s 			page 13


 243              		.syntax unified
 244              		.thumb
 245              		.thumb_func
 246              		.fpu fpv4-sp-d16
 248              	modem_interface_transfer_bytes:
 249              	.LFB134:
 441:../../shields/Murata/src/modem_interface.c **** 
 442:../../shields/Murata/src/modem_interface.c **** /** @Brief Processes events on UART interrupt line
 443:../../shields/Murata/src/modem_interface.c ****  *  @return void
 444:../../shields/Murata/src/modem_interface.c ****  */
 445:../../shields/Murata/src/modem_interface.c **** // static void uart_int_cb(pin_id_t pin_id, uint8_t event_mask)
 446:../../shields/Murata/src/modem_interface.c **** // {
 447:../../shields/Murata/src/modem_interface.c **** //   // do not read GPIO level here in interrupt context (GPIO clock might not be enabled yet), exe
 448:../../shields/Murata/src/modem_interface.c **** //   //sched_post_task(&execute_state_machine);
 449:../../shields/Murata/src/modem_interface.c **** // }
 450:../../shields/Murata/src/modem_interface.c **** 
 451:../../shields/Murata/src/modem_interface.c **** // static void modem_interface_set_rx_interrupt_callback(uart_rx_inthandler_t uart_rx_cb) {
 452:../../shields/Murata/src/modem_interface.c **** // #ifdef PLATFORM_USE_USB_CDC
 453:../../shields/Murata/src/modem_interface.c **** // 	cdc_set_rx_interrupt_callback(uart_rx_cb);
 454:../../shields/Murata/src/modem_interface.c **** // #else
 455:../../shields/Murata/src/modem_interface.c **** //   uart_set_rx_interrupt_callback(uart, uart_rx_cb);
 456:../../shields/Murata/src/modem_interface.c **** // #endif
 457:../../shields/Murata/src/modem_interface.c **** // }
 458:../../shields/Murata/src/modem_interface.c **** 
 459:../../shields/Murata/src/modem_interface.c **** //void modem_interface_init(uint8_t idx, uint32_t baudrate, pin_id_t uart_state_int_pin, pin_id_t t
 460:../../shields/Murata/src/modem_interface.c **** void modem_interface_init(UART_HandleTypeDef* uart)
 461:../../shields/Murata/src/modem_interface.c **** {
 462:../../shields/Murata/src/modem_interface.c ****   uart_handle = uart;
 463:../../shields/Murata/src/modem_interface.c ****   fifo_init(&modem_interface_tx_fifo, modem_interface_tx_buffer, MODEM_INTERFACE_TX_FIFO_SIZE);
 464:../../shields/Murata/src/modem_interface.c ****   //sched_register_task(&flush_modem_interface_tx_fifo);
 465:../../shields/Murata/src/modem_interface.c ****   flush_modem_interface_tx_fifo(NULL);
 466:../../shields/Murata/src/modem_interface.c ****   //sched_register_task(&execute_state_machine);
 467:../../shields/Murata/src/modem_interface.c ****   execute_state_machine();
 468:../../shields/Murata/src/modem_interface.c ****   //sched_register_task(&process_rx_fifo);
 469:../../shields/Murata/src/modem_interface.c ****   process_rx_fifo();
 470:../../shields/Murata/src/modem_interface.c ****   state = STATE_IDLE;
 471:../../shields/Murata/src/modem_interface.c ****   //uart_state_pin=uart_state_int_pin;
 472:../../shields/Murata/src/modem_interface.c ****   //target_uart_state_pin=target_uart_state_int_pin;
 473:../../shields/Murata/src/modem_interface.c **** 
 474:../../shields/Murata/src/modem_interface.c ****   //uart = uart_init(idx, baudrate,0);
 475:../../shields/Murata/src/modem_interface.c ****   
 476:../../shields/Murata/src/modem_interface.c ****   
 477:../../shields/Murata/src/modem_interface.c ****   fifo_init(&rx_fifo, rx_buffer, sizeof(rx_buffer));
 478:../../shields/Murata/src/modem_interface.c ****   //modem_interface_set_rx_interrupt_callback(&uart_rx_cb);
 479:../../shields/Murata/src/modem_interface.c **** 
 480:../../shields/Murata/src/modem_interface.c ****   HAL_UART_Receive_IT(uart_handle, rxData, 1);
 481:../../shields/Murata/src/modem_interface.c **** 
 482:../../shields/Murata/src/modem_interface.c **** #if PLATFORM_USE_MODEM_INTERRUPT_LINES
 483:../../shields/Murata/src/modem_interface.c ****   //assert(sched_register_task(&modem_listen) == SUCCESS);
 484:../../shields/Murata/src/modem_interface.c ****   DPRINT("using interrupt lines");
 485:../../shields/Murata/src/modem_interface.c ****   //assert(hw_gpio_configure_interrupt(target_uart_state_pin, &uart_int_cb, GPIO_RISING_EDGE | GPIO
 486:../../shields/Murata/src/modem_interface.c ****   //assert(hw_gpio_enable_interrupt(target_uart_state_pin) == SUCCESS);
 487:../../shields/Murata/src/modem_interface.c ****   //if(hw_gpio_get_in(target_uart_state_pin))
 488:../../shields/Murata/src/modem_interface.c ****   if(HAL_GPIO_ReadPin(GPIOF, GPIO_PIN_5))
 489:../../shields/Murata/src/modem_interface.c ****   {
 490:../../shields/Murata/src/modem_interface.c ****     //sched_post_task(&modem_listen);
 491:../../shields/Murata/src/modem_interface.c ****     modem_listen(NULL);
ARM GAS  /tmp/ccpCMSI5.s 			page 14


 492:../../shields/Murata/src/modem_interface.c ****     DPRINT("Ready to receive (boot)");// @ %i",timer_get_counter_value());
 493:../../shields/Murata/src/modem_interface.c ****   }
 494:../../shields/Murata/src/modem_interface.c **** #endif
 495:../../shields/Murata/src/modem_interface.c **** 
 496:../../shields/Murata/src/modem_interface.c **** // When not using interrupt lines we keep uart enabled so we can use RX IRQ.
 497:../../shields/Murata/src/modem_interface.c **** // If the platform has interrupt lines the UART should be re-enabled when handling the modem interr
 498:../../shields/Murata/src/modem_interface.c **** #ifndef PLATFORM_USE_MODEM_INTERRUPT_LINES
 499:../../shields/Murata/src/modem_interface.c ****   modem_interface_enable();
 500:../../shields/Murata/src/modem_interface.c **** #endif
 501:../../shields/Murata/src/modem_interface.c **** 
 502:../../shields/Murata/src/modem_interface.c ****   //uint8_t reboot_reason = (uint8_t)hw_system_reboot_reason();
 503:../../shields/Murata/src/modem_interface.c ****   //modem_interface_transfer_bytes(&reboot_reason, 1, SERIAL_MESSAGE_TYPE_REBOOTED);
 504:../../shields/Murata/src/modem_interface.c **** }
 505:../../shields/Murata/src/modem_interface.c **** 
 506:../../shields/Murata/src/modem_interface.c **** void modem_interface_transfer_bytes(uint8_t* bytes, uint8_t length, serial_message_type_t type) 
 507:../../shields/Murata/src/modem_interface.c **** {
 250              		.loc 1 507 0
 251              		.cfi_startproc
 252              		@ args = 0, pretend = 0, frame = 8
 253              		@ frame_needed = 0, uses_anonymous_args = 0
 254              	.LVL18:
 255 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 256              	.LCFI8:
 257              		.cfi_def_cfa_offset 20
 258              		.cfi_offset 4, -20
 259              		.cfi_offset 5, -16
 260              		.cfi_offset 6, -12
 261              		.cfi_offset 7, -8
 262              		.cfi_offset 14, -4
 263 0002 83B0     		sub	sp, sp, #12
 264              	.LCFI9:
 265              		.cfi_def_cfa_offset 32
 266 0004 0746     		mov	r7, r0
 267 0006 0E46     		mov	r6, r1
 268 0008 1546     		mov	r5, r2
 508:../../shields/Murata/src/modem_interface.c ****   uint8_t header[SERIAL_FRAME_HEADER_SIZE];
 509:../../shields/Murata/src/modem_interface.c ****   uint16_t crc=crc_calculate(bytes,length);
 269              		.loc 1 509 0
 270 000a FFF7FEFF 		bl	crc_calculate
 271              	.LVL19:
 510:../../shields/Murata/src/modem_interface.c **** 
 511:../../shields/Murata/src/modem_interface.c ****   packet_up_counter++;
 272              		.loc 1 511 0
 273 000e 134A     		ldr	r2, .L21
 274 0010 1378     		ldrb	r3, [r2]	@ zero_extendqisi2
 275 0012 0133     		adds	r3, r3, #1
 276 0014 DBB2     		uxtb	r3, r3
 277 0016 1370     		strb	r3, [r2]
 512:../../shields/Murata/src/modem_interface.c ****   header[0] = SERIAL_FRAME_SYNC_BYTE;
 278              		.loc 1 512 0
 279 0018 C022     		movs	r2, #192
 280 001a 8DF80020 		strb	r2, [sp]
 513:../../shields/Murata/src/modem_interface.c ****   header[1] = SERIAL_FRAME_VERSION;
 281              		.loc 1 513 0
 282 001e 0024     		movs	r4, #0
 283 0020 8DF80140 		strb	r4, [sp, #1]
 514:../../shields/Murata/src/modem_interface.c **** 
ARM GAS  /tmp/ccpCMSI5.s 			page 15


 515:../../shields/Murata/src/modem_interface.c ****   header[SERIAL_FRAME_COUNTER] = packet_up_counter;
 284              		.loc 1 515 0
 285 0024 8DF80230 		strb	r3, [sp, #2]
 516:../../shields/Murata/src/modem_interface.c ****   header[SERIAL_FRAME_TYPE] = type;
 286              		.loc 1 516 0
 287 0028 8DF80350 		strb	r5, [sp, #3]
 517:../../shields/Murata/src/modem_interface.c ****   header[SERIAL_FRAME_SIZE] = length;
 288              		.loc 1 517 0
 289 002c 8DF80460 		strb	r6, [sp, #4]
 518:../../shields/Murata/src/modem_interface.c ****   header[SERIAL_FRAME_CRC1] = (crc >> 8) & 0x00FF;
 290              		.loc 1 518 0
 291 0030 030A     		lsrs	r3, r0, #8
 292 0032 8DF80530 		strb	r3, [sp, #5]
 519:../../shields/Murata/src/modem_interface.c ****   header[SERIAL_FRAME_CRC2] = crc & 0x00FF;
 293              		.loc 1 519 0
 294 0036 8DF80600 		strb	r0, [sp, #6]
 520:../../shields/Murata/src/modem_interface.c **** 
 521:../../shields/Murata/src/modem_interface.c ****   DPRINT("TX HEADER:");
 522:../../shields/Murata/src/modem_interface.c ****   DPRINT_DATA(header, SERIAL_FRAME_HEADER_SIZE);
 523:../../shields/Murata/src/modem_interface.c ****   DPRINT("TX PAYLOAD:");
 524:../../shields/Murata/src/modem_interface.c ****   DPRINT_DATA(bytes, length);
 525:../../shields/Murata/src/modem_interface.c ****    
 526:../../shields/Murata/src/modem_interface.c **** //  start_atomic();
 527:../../shields/Murata/src/modem_interface.c ****   request_pending = true;
 528:../../shields/Murata/src/modem_interface.c ****   fifo_put(&modem_interface_tx_fifo, (uint8_t*) &header, SERIAL_FRAME_HEADER_SIZE);
 295              		.loc 1 528 0
 296 003a 094D     		ldr	r5, .L21+4
 297 003c 0722     		movs	r2, #7
 298 003e 6946     		mov	r1, sp
 299 0040 2846     		mov	r0, r5
 300              	.LVL20:
 301 0042 FFF7FEFF 		bl	fifo_put
 302              	.LVL21:
 529:../../shields/Murata/src/modem_interface.c ****   fifo_put(&modem_interface_tx_fifo, bytes, length);
 303              		.loc 1 529 0
 304 0046 3246     		mov	r2, r6
 305 0048 3946     		mov	r1, r7
 306 004a 2846     		mov	r0, r5
 307 004c FFF7FEFF 		bl	fifo_put
 308              	.LVL22:
 530:../../shields/Murata/src/modem_interface.c ****  // end_atomic();
 531:../../shields/Murata/src/modem_interface.c **** 
 532:../../shields/Murata/src/modem_interface.c **** #if PLATFORM_USE_MODEM_INTERRUPT_LINES
 533:../../shields/Murata/src/modem_interface.c ****   //sched_post_task_prio(&execute_state_machine, MIN_PRIORITY, NULL);
 534:../../shields/Murata/src/modem_interface.c ****     execute_state_machine();
 535:../../shields/Murata/src/modem_interface.c **** #else
 536:../../shields/Murata/src/modem_interface.c ****   //sched_post_task_prio(&flush_modem_interface_tx_fifo, MIN_PRIORITY, NULL); // state machine is n
 537:../../shields/Murata/src/modem_interface.c ****     flush_modem_interface_tx_fifo(NULL);
 309              		.loc 1 537 0
 310 0050 2046     		mov	r0, r4
 311 0052 FFF7FEFF 		bl	flush_modem_interface_tx_fifo
 312              	.LVL23:
 538:../../shields/Murata/src/modem_interface.c **** #endif  
 539:../../shields/Murata/src/modem_interface.c **** }
 313              		.loc 1 539 0
 314 0056 03B0     		add	sp, sp, #12
 315              	.LCFI10:
ARM GAS  /tmp/ccpCMSI5.s 			page 16


 316              		.cfi_def_cfa_offset 20
 317              		@ sp needed
 318 0058 F0BD     		pop	{r4, r5, r6, r7, pc}
 319              	.LVL24:
 320              	.L22:
 321 005a 00BF     		.align	2
 322              	.L21:
 323 005c 00000000 		.word	.LANCHOR2
 324 0060 00000000 		.word	.LANCHOR1
 325              		.cfi_endproc
 326              	.LFE134:
 328              		.section	.text.process_rx_fifo,"ax",%progbits
 329              		.align	1
 330              		.global	process_rx_fifo
 331              		.syntax unified
 332              		.thumb
 333              		.thumb_func
 334              		.fpu fpv4-sp-d16
 336              	process_rx_fifo:
 337              	.LFB130:
 334:../../shields/Murata/src/modem_interface.c ****   if(!parsed_header) 
 338              		.loc 1 334 0
 339              		.cfi_startproc
 340              		@ args = 0, pretend = 0, frame = 24
 341              		@ frame_needed = 0, uses_anonymous_args = 0
 342 0000 30B5     		push	{r4, r5, lr}
 343              	.LCFI11:
 344              		.cfi_def_cfa_offset 12
 345              		.cfi_offset 4, -12
 346              		.cfi_offset 5, -8
 347              		.cfi_offset 14, -4
 348 0002 87B0     		sub	sp, sp, #28
 349              	.LCFI12:
 350              		.cfi_def_cfa_offset 40
 335:../../shields/Murata/src/modem_interface.c ****   {
 351              		.loc 1 335 0
 352 0004 4E4B     		ldr	r3, .L45
 353 0006 1C78     		ldrb	r4, [r3]	@ zero_extendqisi2
 354 0008 5CBB     		cbnz	r4, .L24
 337:../../shields/Murata/src/modem_interface.c ****     {
 355              		.loc 1 337 0
 356 000a 4E48     		ldr	r0, .L45+4
 357 000c FFF7FEFF 		bl	fifo_get_size
 358              	.LVL25:
 359 0010 0728     		cmp	r0, #7
 360 0012 2ED9     		bls	.L25
 339:../../shields/Murata/src/modem_interface.c **** 
 361              		.loc 1 339 0
 362 0014 4C4D     		ldr	r5, .L45+8
 363 0016 0723     		movs	r3, #7
 364 0018 0022     		movs	r2, #0
 365 001a 2946     		mov	r1, r5
 366 001c 4948     		ldr	r0, .L45+4
 367 001e FFF7FEFF 		bl	fifo_peek
 368              	.LVL26:
 341:../../shields/Murata/src/modem_interface.c ****         {
 369              		.loc 1 341 0
ARM GAS  /tmp/ccpCMSI5.s 			page 17


 370 0022 2B78     		ldrb	r3, [r5]	@ zero_extendqisi2
 371 0024 C02B     		cmp	r3, #192
 372 0026 01D1     		bne	.L26
 341:../../shields/Murata/src/modem_interface.c ****         {
 373              		.loc 1 341 0 is_stmt 0 discriminator 1
 374 0028 6B78     		ldrb	r3, [r5, #1]	@ zero_extendqisi2
 375 002a 73B1     		cbz	r3, .L27
 376              	.L26:
 343:../../shields/Murata/src/modem_interface.c ****           DPRINT("skip");
 377              		.loc 1 343 0 is_stmt 1
 378 002c 454D     		ldr	r5, .L45+4
 379 002e 0121     		movs	r1, #1
 380 0030 2846     		mov	r0, r5
 381 0032 FFF7FEFF 		bl	fifo_skip
 382              	.LVL27:
 345:../../shields/Murata/src/modem_interface.c ****           payload_len = 0;
 383              		.loc 1 345 0
 384 0036 0023     		movs	r3, #0
 385 0038 414A     		ldr	r2, .L45
 386 003a 1370     		strb	r3, [r2]
 346:../../shields/Murata/src/modem_interface.c ****           if(fifo_get_size(&rx_fifo) > SERIAL_FRAME_HEADER_SIZE)
 387              		.loc 1 346 0
 388 003c 434A     		ldr	r2, .L45+12
 389 003e 1370     		strb	r3, [r2]
 347:../../shields/Murata/src/modem_interface.c ****             //process_rx_fifo();
 390              		.loc 1 347 0
 391 0040 2846     		mov	r0, r5
 392 0042 FFF7FEFF 		bl	fifo_get_size
 393              	.LVL28:
 394 0046 0728     		cmp	r0, #7
 395 0048 13D8     		bhi	.L25
 396              	.L27:
 352:../../shields/Murata/src/modem_interface.c ****         fifo_skip(&rx_fifo, SERIAL_FRAME_HEADER_SIZE);
 397              		.loc 1 352 0
 398 004a 3D4B     		ldr	r3, .L45
 399 004c 0122     		movs	r2, #1
 400 004e 1A70     		strb	r2, [r3]
 353:../../shields/Murata/src/modem_interface.c ****         payload_len = header[SERIAL_FRAME_SIZE];
 401              		.loc 1 353 0
 402 0050 0721     		movs	r1, #7
 403 0052 3C48     		ldr	r0, .L45+4
 404 0054 FFF7FEFF 		bl	fifo_skip
 405              	.LVL29:
 354:../../shields/Murata/src/modem_interface.c ****         DPRINT("UART RX, payload size = %i", payload_len);
 406              		.loc 1 354 0
 407 0058 3B4B     		ldr	r3, .L45+8
 408 005a 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 409 005c 3B4B     		ldr	r3, .L45+12
 410 005e 1A70     		strb	r2, [r3]
 411 0060 07E0     		b	.L25
 412              	.L24:
 413              	.LBB2:
 362:../../shields/Murata/src/modem_interface.c ****       //process_rx_fifo();
 414              		.loc 1 362 0
 415 0062 3848     		ldr	r0, .L45+4
 416 0064 FFF7FEFF 		bl	fifo_get_size
 417              	.LVL30:
ARM GAS  /tmp/ccpCMSI5.s 			page 18


 418 0068 384B     		ldr	r3, .L45+12
 419 006a 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 420 006c 9842     		cmp	r0, r3
 421 006e 03D2     		bcs	.L39
 364:../../shields/Murata/src/modem_interface.c ****     }
 422              		.loc 1 364 0
 423 0070 0024     		movs	r4, #0
 424              	.L25:
 425              	.LBE2:
 411:../../shields/Murata/src/modem_interface.c **** /** @Brief put received UART data in fifo
 426              		.loc 1 411 0
 427 0072 2046     		mov	r0, r4
 428 0074 07B0     		add	sp, sp, #28
 429              	.LCFI13:
 430              		.cfi_remember_state
 431              		.cfi_def_cfa_offset 12
 432              		@ sp needed
 433 0076 30BD     		pop	{r4, r5, pc}
 434              	.L39:
 435              	.LCFI14:
 436              		.cfi_restore_state
 437              	.LBB5:
 370:../../shields/Murata/src/modem_interface.c ****   
 438              		.loc 1 370 0
 439 0078 0022     		movs	r2, #0
 440 007a 3249     		ldr	r1, .L45+4
 441 007c 02A8     		add	r0, sp, #8
 442 007e FFF7FEFF 		bl	fifo_init_subview
 443              	.LVL31:
 372:../../shields/Murata/src/modem_interface.c ****     {
 444              		.loc 1 372 0
 445 0082 3149     		ldr	r1, .L45+8
 446 0084 02A8     		add	r0, sp, #8
 447 0086 FFF7FEFF 		bl	verify_payload
 448              	.LVL32:
 449 008a 08B3     		cbz	r0, .L29
 374:../../shields/Murata/src/modem_interface.c ****         alp_handler(&payload_fifo);
 450              		.loc 1 374 0
 451 008c 2E4B     		ldr	r3, .L45+8
 452 008e DB78     		ldrb	r3, [r3, #3]	@ zero_extendqisi2
 453 0090 012B     		cmp	r3, #1
 454 0092 0DD0     		beq	.L40
 455              	.L30:
 376:../../shields/Murata/src/modem_interface.c ****         ping_response_handler(&payload_fifo);
 456              		.loc 1 376 0
 457 0094 032B     		cmp	r3, #3
 458 0096 27D0     		beq	.L41
 459              	.L32:
 378:../../shields/Murata/src/modem_interface.c ****         logging_handler(&payload_fifo);
 460              		.loc 1 378 0
 461 0098 042B     		cmp	r3, #4
 462 009a 2CD0     		beq	.L42
 463              	.L33:
 380:../../shields/Murata/src/modem_interface.c ****       {
 464              		.loc 1 380 0
 465 009c 022B     		cmp	r3, #2
 466 009e 31D0     		beq	.L43
ARM GAS  /tmp/ccpCMSI5.s 			page 19


 386:../../shields/Murata/src/modem_interface.c ****       {
 467              		.loc 1 386 0
 468 00a0 052B     		cmp	r3, #5
 469 00a2 3BD0     		beq	.L44
 396:../../shields/Murata/src/modem_interface.c ****         DPRINT("!!!FRAME TYPE NOT IMPLEMENTED");
 470              		.loc 1 396 0
 471 00a4 294B     		ldr	r3, .L45+12
 472 00a6 1978     		ldrb	r1, [r3]	@ zero_extendqisi2
 473 00a8 02A8     		add	r0, sp, #8
 474 00aa FFF7FEFF 		bl	fifo_skip
 475              	.LVL33:
 476 00ae 05E0     		b	.L31
 477              	.L40:
 374:../../shields/Murata/src/modem_interface.c ****         alp_handler(&payload_fifo);
 478              		.loc 1 374 0 discriminator 1
 479 00b0 274A     		ldr	r2, .L45+16
 480 00b2 1268     		ldr	r2, [r2]
 481 00b4 002A     		cmp	r2, #0
 482 00b6 EDD0     		beq	.L30
 375:../../shields/Murata/src/modem_interface.c ****       else if (header[SERIAL_FRAME_TYPE]==SERIAL_MESSAGE_TYPE_PING_RESPONSE  && ping_response_handl
 483              		.loc 1 375 0
 484 00b8 02A8     		add	r0, sp, #8
 485 00ba 9047     		blx	r2
 486              	.LVL34:
 487              	.L31:
 399:../../shields/Murata/src/modem_interface.c ****     }
 488              		.loc 1 399 0
 489 00bc 234B     		ldr	r3, .L45+12
 490 00be 1D78     		ldrb	r5, [r3]	@ zero_extendqisi2
 491 00c0 02A8     		add	r0, sp, #8
 492 00c2 FFF7FEFF 		bl	fifo_get_size
 493              	.LVL35:
 494 00c6 291A     		subs	r1, r5, r0
 495 00c8 89B2     		uxth	r1, r1
 496 00ca 1E48     		ldr	r0, .L45+4
 497 00cc FFF7FEFF 		bl	fifo_skip
 498              	.LVL36:
 499              	.L29:
 403:../../shields/Murata/src/modem_interface.c ****     parsed_header = false;
 500              		.loc 1 403 0
 501 00d0 0023     		movs	r3, #0
 502 00d2 1E4A     		ldr	r2, .L45+12
 503 00d4 1370     		strb	r3, [r2]
 404:../../shields/Murata/src/modem_interface.c ****     if(fifo_get_size(&rx_fifo) > SERIAL_FRAME_HEADER_SIZE)
 504              		.loc 1 404 0
 505 00d6 1A4A     		ldr	r2, .L45
 506 00d8 1370     		strb	r3, [r2]
 405:../../shields/Murata/src/modem_interface.c ****         //process_rx_fifo();
 507              		.loc 1 405 0
 508 00da 1A48     		ldr	r0, .L45+4
 509 00dc FFF7FEFF 		bl	fifo_get_size
 510              	.LVL37:
 511 00e0 0728     		cmp	r0, #7
 512 00e2 C6D8     		bhi	.L25
 513              	.LBE5:
 410:../../shields/Murata/src/modem_interface.c **** }
 514              		.loc 1 410 0
ARM GAS  /tmp/ccpCMSI5.s 			page 20


 515 00e4 0024     		movs	r4, #0
 516              	.LBB6:
 517 00e6 C4E7     		b	.L25
 518              	.L41:
 376:../../shields/Murata/src/modem_interface.c ****         ping_response_handler(&payload_fifo);
 519              		.loc 1 376 0 discriminator 1
 520 00e8 1A4A     		ldr	r2, .L45+20
 521 00ea 1268     		ldr	r2, [r2]
 522 00ec 002A     		cmp	r2, #0
 523 00ee D3D0     		beq	.L32
 377:../../shields/Murata/src/modem_interface.c ****       else if (header[SERIAL_FRAME_TYPE]==SERIAL_MESSAGE_TYPE_LOGGING && logging_handler != NULL)
 524              		.loc 1 377 0
 525 00f0 02A8     		add	r0, sp, #8
 526 00f2 9047     		blx	r2
 527              	.LVL38:
 528 00f4 E2E7     		b	.L31
 529              	.L42:
 378:../../shields/Murata/src/modem_interface.c ****         logging_handler(&payload_fifo);
 530              		.loc 1 378 0 discriminator 1
 531 00f6 184A     		ldr	r2, .L45+24
 532 00f8 1268     		ldr	r2, [r2]
 533 00fa 002A     		cmp	r2, #0
 534 00fc CED0     		beq	.L33
 379:../../shields/Murata/src/modem_interface.c ****       else if (header[SERIAL_FRAME_TYPE]==SERIAL_MESSAGE_TYPE_PING_REQUEST)
 535              		.loc 1 379 0
 536 00fe 02A8     		add	r0, sp, #8
 537 0100 9047     		blx	r2
 538              	.LVL39:
 539 0102 DBE7     		b	.L31
 540              	.L43:
 541              	.LBB3:
 382:../../shields/Murata/src/modem_interface.c ****         fifo_skip(&payload_fifo,1);
 542              		.loc 1 382 0
 543 0104 8DF80430 		strb	r3, [sp, #4]
 383:../../shields/Murata/src/modem_interface.c ****         modem_interface_transfer_bytes((uint8_t*) &ping_reply,1,SERIAL_MESSAGE_TYPE_PING_RESPONSE);
 544              		.loc 1 383 0
 545 0108 0121     		movs	r1, #1
 546 010a 02A8     		add	r0, sp, #8
 547 010c FFF7FEFF 		bl	fifo_skip
 548              	.LVL40:
 384:../../shields/Murata/src/modem_interface.c ****       }
 549              		.loc 1 384 0
 550 0110 0322     		movs	r2, #3
 551 0112 0121     		movs	r1, #1
 552 0114 01A8     		add	r0, sp, #4
 553 0116 FFF7FEFF 		bl	modem_interface_transfer_bytes
 554              	.LVL41:
 555              	.LBE3:
 556 011a CFE7     		b	.L31
 557              	.L44:
 558              	.LBB4:
 389:../../shields/Murata/src/modem_interface.c ****         printf("target rebooted, reason=%i\n", reboot_reason);
 559              		.loc 1 389 0
 560 011c 0122     		movs	r2, #1
 561 011e 01A9     		add	r1, sp, #4
 562 0120 02A8     		add	r0, sp, #8
 563 0122 FFF7FEFF 		bl	fifo_pop
ARM GAS  /tmp/ccpCMSI5.s 			page 21


 564              	.LVL42:
 390:../../shields/Murata/src/modem_interface.c ****         if(target_rebooted_cb)
 565              		.loc 1 390 0
 566 0126 9DF80410 		ldrb	r1, [sp, #4]	@ zero_extendqisi2
 567 012a 0C48     		ldr	r0, .L45+28
 568 012c FFF7FEFF 		bl	printf
 569              	.LVL43:
 391:../../shields/Murata/src/modem_interface.c ****           target_rebooted_cb(reboot_reason);
 570              		.loc 1 391 0
 571 0130 0B4B     		ldr	r3, .L45+32
 572 0132 1B68     		ldr	r3, [r3]
 573 0134 002B     		cmp	r3, #0
 574 0136 C1D0     		beq	.L31
 392:../../shields/Murata/src/modem_interface.c ****       }
 575              		.loc 1 392 0
 576 0138 9DF80400 		ldrb	r0, [sp, #4]	@ zero_extendqisi2
 577 013c 9847     		blx	r3
 578              	.LVL44:
 579 013e BDE7     		b	.L31
 580              	.L46:
 581              		.align	2
 582              	.L45:
 583 0140 00000000 		.word	.LANCHOR3
 584 0144 00000000 		.word	rx_fifo
 585 0148 00000000 		.word	header
 586 014c 00000000 		.word	.LANCHOR4
 587 0150 00000000 		.word	.LANCHOR5
 588 0154 00000000 		.word	.LANCHOR6
 589 0158 00000000 		.word	.LANCHOR7
 590 015c 00000000 		.word	.LC0
 591 0160 00000000 		.word	.LANCHOR8
 592              	.LBE4:
 593              	.LBE6:
 594              		.cfi_endproc
 595              	.LFE130:
 597              		.section	.text.modem_interface_init,"ax",%progbits
 598              		.align	1
 599              		.global	modem_interface_init
 600              		.syntax unified
 601              		.thumb
 602              		.thumb_func
 603              		.fpu fpv4-sp-d16
 605              	modem_interface_init:
 606              	.LFB133:
 461:../../shields/Murata/src/modem_interface.c ****   uart_handle = uart;
 607              		.loc 1 461 0
 608              		.cfi_startproc
 609              		@ args = 0, pretend = 0, frame = 0
 610              		@ frame_needed = 0, uses_anonymous_args = 0
 611              	.LVL45:
 612 0000 10B5     		push	{r4, lr}
 613              	.LCFI15:
 614              		.cfi_def_cfa_offset 8
 615              		.cfi_offset 4, -8
 616              		.cfi_offset 14, -4
 462:../../shields/Murata/src/modem_interface.c ****   fifo_init(&modem_interface_tx_fifo, modem_interface_tx_buffer, MODEM_INTERFACE_TX_FIFO_SIZE);
 617              		.loc 1 462 0
ARM GAS  /tmp/ccpCMSI5.s 			page 22


 618 0002 0C4C     		ldr	r4, .L49
 619 0004 2060     		str	r0, [r4]
 463:../../shields/Murata/src/modem_interface.c ****   //sched_register_task(&flush_modem_interface_tx_fifo);
 620              		.loc 1 463 0
 621 0006 FF22     		movs	r2, #255
 622 0008 0B49     		ldr	r1, .L49+4
 623 000a 0C48     		ldr	r0, .L49+8
 624              	.LVL46:
 625 000c FFF7FEFF 		bl	fifo_init
 626              	.LVL47:
 465:../../shields/Murata/src/modem_interface.c ****   //sched_register_task(&execute_state_machine);
 627              		.loc 1 465 0
 628 0010 0020     		movs	r0, #0
 629 0012 FFF7FEFF 		bl	flush_modem_interface_tx_fifo
 630              	.LVL48:
 469:../../shields/Murata/src/modem_interface.c ****   state = STATE_IDLE;
 631              		.loc 1 469 0
 632 0016 FFF7FEFF 		bl	process_rx_fifo
 633              	.LVL49:
 477:../../shields/Murata/src/modem_interface.c ****   //modem_interface_set_rx_interrupt_callback(&uart_rx_cb);
 634              		.loc 1 477 0
 635 001a 4FF48072 		mov	r2, #256
 636 001e 0849     		ldr	r1, .L49+12
 637 0020 0848     		ldr	r0, .L49+16
 638 0022 FFF7FEFF 		bl	fifo_init
 639              	.LVL50:
 480:../../shields/Murata/src/modem_interface.c **** 
 640              		.loc 1 480 0
 641 0026 0122     		movs	r2, #1
 642 0028 0749     		ldr	r1, .L49+20
 643 002a 2068     		ldr	r0, [r4]
 644 002c FFF7FEFF 		bl	HAL_UART_Receive_IT
 645              	.LVL51:
 504:../../shields/Murata/src/modem_interface.c **** 
 646              		.loc 1 504 0
 647 0030 10BD     		pop	{r4, pc}
 648              	.L50:
 649 0032 00BF     		.align	2
 650              	.L49:
 651 0034 00000000 		.word	uart_handle
 652 0038 00000000 		.word	.LANCHOR9
 653 003c 00000000 		.word	.LANCHOR1
 654 0040 00000000 		.word	.LANCHOR10
 655 0044 00000000 		.word	rx_fifo
 656 0048 00000000 		.word	rxData
 657              		.cfi_endproc
 658              	.LFE133:
 660              		.section	.text.modem_interface_transfer,"ax",%progbits
 661              		.align	1
 662              		.global	modem_interface_transfer
 663              		.syntax unified
 664              		.thumb
 665              		.thumb_func
 666              		.fpu fpv4-sp-d16
 668              	modem_interface_transfer:
 669              	.LFB135:
 540:../../shields/Murata/src/modem_interface.c **** 
ARM GAS  /tmp/ccpCMSI5.s 			page 23


 541:../../shields/Murata/src/modem_interface.c **** void modem_interface_transfer(char* string) {
 670              		.loc 1 541 0
 671              		.cfi_startproc
 672              		@ args = 0, pretend = 0, frame = 0
 673              		@ frame_needed = 0, uses_anonymous_args = 0
 674              	.LVL52:
 675 0000 10B5     		push	{r4, lr}
 676              	.LCFI16:
 677              		.cfi_def_cfa_offset 8
 678              		.cfi_offset 4, -8
 679              		.cfi_offset 14, -4
 680 0002 0446     		mov	r4, r0
 542:../../shields/Murata/src/modem_interface.c ****   modem_interface_transfer_bytes((uint8_t*) string, strnlen(string, 100), SERIAL_MESSAGE_TYPE_LOGGI
 681              		.loc 1 542 0
 682 0004 6421     		movs	r1, #100
 683 0006 FFF7FEFF 		bl	strnlen
 684              	.LVL53:
 685 000a 0422     		movs	r2, #4
 686 000c C1B2     		uxtb	r1, r0
 687 000e 2046     		mov	r0, r4
 688 0010 FFF7FEFF 		bl	modem_interface_transfer_bytes
 689              	.LVL54:
 543:../../shields/Murata/src/modem_interface.c **** }
 690              		.loc 1 543 0
 691 0014 10BD     		pop	{r4, pc}
 692              		.cfi_endproc
 693              	.LFE135:
 695              		.section	.text.modem_interface_register_handler,"ax",%progbits
 696              		.align	1
 697              		.global	modem_interface_register_handler
 698              		.syntax unified
 699              		.thumb
 700              		.thumb_func
 701              		.fpu fpv4-sp-d16
 703              	modem_interface_register_handler:
 704              	.LFB136:
 544:../../shields/Murata/src/modem_interface.c **** 
 545:../../shields/Murata/src/modem_interface.c **** 
 546:../../shields/Murata/src/modem_interface.c **** void modem_interface_register_handler(cmd_handler_t cmd_handler, serial_message_type_t type)
 547:../../shields/Murata/src/modem_interface.c **** {
 705              		.loc 1 547 0
 706              		.cfi_startproc
 707              		@ args = 0, pretend = 0, frame = 0
 708              		@ frame_needed = 0, uses_anonymous_args = 0
 709              		@ link register save eliminated.
 710              	.LVL55:
 548:../../shields/Murata/src/modem_interface.c ****   if(type == SERIAL_MESSAGE_TYPE_ALP_DATA) 
 711              		.loc 1 548 0
 712 0000 0129     		cmp	r1, #1
 713 0002 04D0     		beq	.L57
 549:../../shields/Murata/src/modem_interface.c ****     alp_handler=cmd_handler;
 550:../../shields/Murata/src/modem_interface.c ****   else if(type == SERIAL_MESSAGE_TYPE_PING_RESPONSE) 
 714              		.loc 1 550 0
 715 0004 0329     		cmp	r1, #3
 716 0006 05D0     		beq	.L58
 551:../../shields/Murata/src/modem_interface.c ****     ping_response_handler=cmd_handler;
 552:../../shields/Murata/src/modem_interface.c ****   else if(type == SERIAL_MESSAGE_TYPE_LOGGING) 
ARM GAS  /tmp/ccpCMSI5.s 			page 24


 717              		.loc 1 552 0
 718 0008 0429     		cmp	r1, #4
 719 000a 06D0     		beq	.L59
 720              	.L53:
 553:../../shields/Murata/src/modem_interface.c ****     logging_handler=cmd_handler;
 554:../../shields/Murata/src/modem_interface.c ****   else
 555:../../shields/Murata/src/modem_interface.c ****     DPRINT("Modem interface callback not implemented");
 556:../../shields/Murata/src/modem_interface.c **** }
 721              		.loc 1 556 0
 722 000c 7047     		bx	lr
 723              	.L57:
 549:../../shields/Murata/src/modem_interface.c ****   else if(type == SERIAL_MESSAGE_TYPE_PING_RESPONSE) 
 724              		.loc 1 549 0
 725 000e 044B     		ldr	r3, .L60
 726 0010 1860     		str	r0, [r3]
 727 0012 7047     		bx	lr
 728              	.L58:
 551:../../shields/Murata/src/modem_interface.c ****     ping_response_handler=cmd_handler;
 729              		.loc 1 551 0
 730 0014 034B     		ldr	r3, .L60+4
 731 0016 1860     		str	r0, [r3]
 732 0018 7047     		bx	lr
 733              	.L59:
 553:../../shields/Murata/src/modem_interface.c ****     logging_handler=cmd_handler;
 734              		.loc 1 553 0
 735 001a 034B     		ldr	r3, .L60+8
 736 001c 1860     		str	r0, [r3]
 737              		.loc 1 556 0
 738 001e F5E7     		b	.L53
 739              	.L61:
 740              		.align	2
 741              	.L60:
 742 0020 00000000 		.word	.LANCHOR5
 743 0024 00000000 		.word	.LANCHOR6
 744 0028 00000000 		.word	.LANCHOR7
 745              		.cfi_endproc
 746              	.LFE136:
 748              		.section	.text.modem_interface_set_target_rebooted_callback,"ax",%progbits
 749              		.align	1
 750              		.global	modem_interface_set_target_rebooted_callback
 751              		.syntax unified
 752              		.thumb
 753              		.thumb_func
 754              		.fpu fpv4-sp-d16
 756              	modem_interface_set_target_rebooted_callback:
 757              	.LFB137:
 557:../../shields/Murata/src/modem_interface.c **** 
 558:../../shields/Murata/src/modem_interface.c **** void modem_interface_set_target_rebooted_callback(target_rebooted_callback_t cb)
 559:../../shields/Murata/src/modem_interface.c **** {
 758              		.loc 1 559 0
 759              		.cfi_startproc
 760              		@ args = 0, pretend = 0, frame = 0
 761              		@ frame_needed = 0, uses_anonymous_args = 0
 762              		@ link register save eliminated.
 763              	.LVL56:
 560:../../shields/Murata/src/modem_interface.c ****   target_rebooted_cb = cb;
 764              		.loc 1 560 0
ARM GAS  /tmp/ccpCMSI5.s 			page 25


 765 0000 014B     		ldr	r3, .L63
 766 0002 1860     		str	r0, [r3]
 561:../../shields/Murata/src/modem_interface.c **** }
 767              		.loc 1 561 0
 768 0004 7047     		bx	lr
 769              	.L64:
 770 0006 00BF     		.align	2
 771              	.L63:
 772 0008 00000000 		.word	.LANCHOR8
 773              		.cfi_endproc
 774              	.LFE137:
 776              		.comm	header,7,4
 777              		.comm	rx_fifo,16,4
 778              		.comm	rxData,1,4
 779              		.comm	uart_handle,4,4
 780              		.section	.bss.alp_handler,"aw",%nobits
 781              		.align	2
 782              		.set	.LANCHOR5,. + 0
 785              	alp_handler:
 786 0000 00000000 		.space	4
 787              		.section	.bss.logging_handler,"aw",%nobits
 788              		.align	2
 789              		.set	.LANCHOR7,. + 0
 792              	logging_handler:
 793 0000 00000000 		.space	4
 794              		.section	.bss.modem_interface_tx_buffer,"aw",%nobits
 795              		.align	2
 796              		.set	.LANCHOR9,. + 0
 799              	modem_interface_tx_buffer:
 800 0000 00000000 		.space	255
 800      00000000 
 800      00000000 
 800      00000000 
 800      00000000 
 801              		.section	.bss.modem_interface_tx_fifo,"aw",%nobits
 802              		.align	2
 803              		.set	.LANCHOR1,. + 0
 806              	modem_interface_tx_fifo:
 807 0000 00000000 		.space	16
 807      00000000 
 807      00000000 
 807      00000000 
 808              		.section	.bss.packet_down_counter,"aw",%nobits
 809              		.set	.LANCHOR0,. + 0
 812              	packet_down_counter:
 813 0000 00       		.space	1
 814              		.section	.bss.packet_up_counter,"aw",%nobits
 815              		.set	.LANCHOR2,. + 0
 818              	packet_up_counter:
 819 0000 00       		.space	1
 820              		.section	.bss.parsed_header,"aw",%nobits
 821              		.set	.LANCHOR3,. + 0
 824              	parsed_header:
 825 0000 00       		.space	1
 826              		.section	.bss.payload_len,"aw",%nobits
 827              		.set	.LANCHOR4,. + 0
 830              	payload_len:
ARM GAS  /tmp/ccpCMSI5.s 			page 26


 831 0000 00       		.space	1
 832              		.section	.bss.ping_response_handler,"aw",%nobits
 833              		.align	2
 834              		.set	.LANCHOR6,. + 0
 837              	ping_response_handler:
 838 0000 00000000 		.space	4
 839              		.section	.bss.rx_buffer,"aw",%nobits
 840              		.align	2
 841              		.set	.LANCHOR10,. + 0
 844              	rx_buffer:
 845 0000 00000000 		.space	256
 845      00000000 
 845      00000000 
 845      00000000 
 845      00000000 
 846              		.section	.bss.target_rebooted_cb,"aw",%nobits
 847              		.align	2
 848              		.set	.LANCHOR8,. + 0
 851              	target_rebooted_cb:
 852 0000 00000000 		.space	4
 853              		.section	.rodata.process_rx_fifo.str1.4,"aMS",%progbits,1
 854              		.align	2
 855              	.LC0:
 856 0000 74617267 		.ascii	"target rebooted, reason=%i\012\000"
 856      65742072 
 856      65626F6F 
 856      7465642C 
 856      20726561 
 857              		.text
 858              	.Letext0:
 859              		.file 2 "/home/mats/gcc-arm-none-eabi-7-2018-q2-update/arm-none-eabi/include/machine/_default_type
 860              		.file 3 "/home/mats/gcc-arm-none-eabi-7-2018-q2-update/arm-none-eabi/include/sys/lock.h"
 861              		.file 4 "/home/mats/gcc-arm-none-eabi-7-2018-q2-update/arm-none-eabi/include/sys/_types.h"
 862              		.file 5 "/home/mats/gcc-arm-none-eabi-7-2018-q2-update/lib/gcc/arm-none-eabi/7.3.1/include/stddef.
 863              		.file 6 "/home/mats/gcc-arm-none-eabi-7-2018-q2-update/arm-none-eabi/include/sys/reent.h"
 864              		.file 7 "/home/mats/gcc-arm-none-eabi-7-2018-q2-update/arm-none-eabi/include/sys/_stdint.h"
 865              		.file 8 "../../shields/Murata/inc/types.h"
 866              		.file 9 "../../shields/Murata/inc/fifo.h"
 867              		.file 10 "../../core/ST/CMSIS/Include/core_cm4.h"
 868              		.file 11 "../../core/ST/CMSIS/Device/ST/STM32L4xx/Include/system_stm32l4xx.h"
 869              		.file 12 "../../core/ST/CMSIS/Device/ST/STM32L4xx/Include/stm32l496xx.h"
 870              		.file 13 "../../core/ST/STM32L4xx_HAL_Driver/Inc/stm32l4xx_hal_def.h"
 871              		.file 14 "../../core/ST/STM32L4xx_HAL_Driver/Inc/stm32l4xx_hal_dma.h"
 872              		.file 15 "../../core/ST/STM32L4xx_HAL_Driver/Inc/stm32l4xx_hal_uart.h"
 873              		.file 16 "../../core/ST/STM32L4xx_HAL_Driver/Inc/stm32l4xx_hal.h"
 874              		.file 17 "../../shields/Murata/inc/modem_interface.h"
 875              		.file 18 "/home/mats/gcc-arm-none-eabi-7-2018-q2-update/arm-none-eabi/include/sys/errno.h"
 876              		.file 19 "/home/mats/gcc-arm-none-eabi-7-2018-q2-update/arm-none-eabi/include/string.h"
 877              		.file 20 "../../shields/Murata/inc/crc.h"
 878              		.file 21 "<built-in>"
ARM GAS  /tmp/ccpCMSI5.s 			page 27


DEFINED SYMBOLS
                            *ABS*:0000000000000000 modem_interface.c
     /tmp/ccpCMSI5.s:18     .text.verify_payload:0000000000000000 $t
     /tmp/ccpCMSI5.s:24     .text.verify_payload:0000000000000000 verify_payload
     /tmp/ccpCMSI5.s:112    .text.verify_payload:0000000000000058 $d
     /tmp/ccpCMSI5.s:117    .text.flush_modem_interface_tx_fifo:0000000000000000 $t
     /tmp/ccpCMSI5.s:123    .text.flush_modem_interface_tx_fifo:0000000000000000 flush_modem_interface_tx_fifo
     /tmp/ccpCMSI5.s:171    .text.flush_modem_interface_tx_fifo:000000000000002c $d
                            *COM*:0000000000000004 uart_handle
     /tmp/ccpCMSI5.s:177    .text.execute_state_machine:0000000000000000 $t
     /tmp/ccpCMSI5.s:184    .text.execute_state_machine:0000000000000000 execute_state_machine
     /tmp/ccpCMSI5.s:197    .text.modem_interface_uart_rx_cb:0000000000000000 $t
     /tmp/ccpCMSI5.s:204    .text.modem_interface_uart_rx_cb:0000000000000000 modem_interface_uart_rx_cb
     /tmp/ccpCMSI5.s:234    .text.modem_interface_uart_rx_cb:000000000000001c $d
                            *COM*:0000000000000001 rxData
                            *COM*:0000000000000010 rx_fifo
     /tmp/ccpCMSI5.s:241    .text.modem_interface_transfer_bytes:0000000000000000 $t
     /tmp/ccpCMSI5.s:248    .text.modem_interface_transfer_bytes:0000000000000000 modem_interface_transfer_bytes
     /tmp/ccpCMSI5.s:323    .text.modem_interface_transfer_bytes:000000000000005c $d
     /tmp/ccpCMSI5.s:329    .text.process_rx_fifo:0000000000000000 $t
     /tmp/ccpCMSI5.s:336    .text.process_rx_fifo:0000000000000000 process_rx_fifo
     /tmp/ccpCMSI5.s:583    .text.process_rx_fifo:0000000000000140 $d
                            *COM*:0000000000000007 header
     /tmp/ccpCMSI5.s:598    .text.modem_interface_init:0000000000000000 $t
     /tmp/ccpCMSI5.s:605    .text.modem_interface_init:0000000000000000 modem_interface_init
     /tmp/ccpCMSI5.s:651    .text.modem_interface_init:0000000000000034 $d
     /tmp/ccpCMSI5.s:661    .text.modem_interface_transfer:0000000000000000 $t
     /tmp/ccpCMSI5.s:668    .text.modem_interface_transfer:0000000000000000 modem_interface_transfer
     /tmp/ccpCMSI5.s:696    .text.modem_interface_register_handler:0000000000000000 $t
     /tmp/ccpCMSI5.s:703    .text.modem_interface_register_handler:0000000000000000 modem_interface_register_handler
     /tmp/ccpCMSI5.s:742    .text.modem_interface_register_handler:0000000000000020 $d
     /tmp/ccpCMSI5.s:749    .text.modem_interface_set_target_rebooted_callback:0000000000000000 $t
     /tmp/ccpCMSI5.s:756    .text.modem_interface_set_target_rebooted_callback:0000000000000000 modem_interface_set_target_rebooted_callback
     /tmp/ccpCMSI5.s:772    .text.modem_interface_set_target_rebooted_callback:0000000000000008 $d
     /tmp/ccpCMSI5.s:781    .bss.alp_handler:0000000000000000 $d
     /tmp/ccpCMSI5.s:785    .bss.alp_handler:0000000000000000 alp_handler
     /tmp/ccpCMSI5.s:788    .bss.logging_handler:0000000000000000 $d
     /tmp/ccpCMSI5.s:792    .bss.logging_handler:0000000000000000 logging_handler
     /tmp/ccpCMSI5.s:795    .bss.modem_interface_tx_buffer:0000000000000000 $d
     /tmp/ccpCMSI5.s:799    .bss.modem_interface_tx_buffer:0000000000000000 modem_interface_tx_buffer
     /tmp/ccpCMSI5.s:802    .bss.modem_interface_tx_fifo:0000000000000000 $d
     /tmp/ccpCMSI5.s:806    .bss.modem_interface_tx_fifo:0000000000000000 modem_interface_tx_fifo
     /tmp/ccpCMSI5.s:812    .bss.packet_down_counter:0000000000000000 packet_down_counter
     /tmp/ccpCMSI5.s:813    .bss.packet_down_counter:0000000000000000 $d
     /tmp/ccpCMSI5.s:818    .bss.packet_up_counter:0000000000000000 packet_up_counter
     /tmp/ccpCMSI5.s:819    .bss.packet_up_counter:0000000000000000 $d
     /tmp/ccpCMSI5.s:824    .bss.parsed_header:0000000000000000 parsed_header
     /tmp/ccpCMSI5.s:825    .bss.parsed_header:0000000000000000 $d
     /tmp/ccpCMSI5.s:830    .bss.payload_len:0000000000000000 payload_len
     /tmp/ccpCMSI5.s:831    .bss.payload_len:0000000000000000 $d
     /tmp/ccpCMSI5.s:833    .bss.ping_response_handler:0000000000000000 $d
     /tmp/ccpCMSI5.s:837    .bss.ping_response_handler:0000000000000000 ping_response_handler
     /tmp/ccpCMSI5.s:840    .bss.rx_buffer:0000000000000000 $d
     /tmp/ccpCMSI5.s:844    .bss.rx_buffer:0000000000000000 rx_buffer
     /tmp/ccpCMSI5.s:847    .bss.target_rebooted_cb:0000000000000000 $d
     /tmp/ccpCMSI5.s:851    .bss.target_rebooted_cb:0000000000000000 target_rebooted_cb
     /tmp/ccpCMSI5.s:854    .rodata.process_rx_fifo.str1.4:0000000000000000 $d
ARM GAS  /tmp/ccpCMSI5.s 			page 28



UNDEFINED SYMBOLS
fifo_peek
crc_calculate
fifo_get_size
fifo_pop
HAL_UART_Transmit
HAL_UART_Receive_IT
fifo_put
fifo_skip
fifo_init_subview
printf
fifo_init
strnlen
